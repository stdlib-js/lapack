{"version":3,"file":"index.mjs","sources":["../base/clacgv/lib/ndarray.js","../base/clacgv/lib/clacgv.js","../base/clacgv/lib/main.js","../base/clacpy/lib/base.js","../base/clacpy/lib/clacpy.js","../base/clacpy/lib/main.js","../base/clacpy/lib/ndarray.js","../base/clacpy/lib/index.js","../6f82c38f3b1796089b16cedaa893b2","../base/claset/lib/base.js","../base/claset/lib/claset.js","../base/claset/lib/main.js","../base/claset/lib/ndarray.js","../base/claset/lib/index.js","../2e76f7ad05ecf6e5b972de6bee6645","../base/crot/lib/ndarray.js","../base/crot/lib/crot.js","../base/crot/lib/main.js","../base/dge-trans/lib/base.js","../base/dge-trans/lib/dgetrans.js","../base/dge-trans/lib/main.js","../base/dge-trans/lib/ndarray.js","../base/dge-trans/lib/index.js","../af7fb90e55374030cac4adcee9b8ad","../base/dlacpy/lib/base.js","../base/dlacpy/lib/dlacpy.js","../base/dlacpy/lib/main.js","../base/dlacpy/lib/ndarray.js","../base/dlacpy/lib/index.js","../b35467d2907816e8be0eefe023be6e","../d91e067919423e04a7f970cc6c34f8","../base/dlassq/lib/base.js","../base/dlassq/lib/dlassq.js","../base/dlassq/lib/main.js","../base/dlassq/lib/ndarray.js","../base/dlassq/lib/index.js","../base/dlaswp/lib/base.js","../base/dlaswp/lib/dlaswp.js","../base/dlaswp/lib/main.js","../base/dlaswp/lib/ndarray.js","../base/dlaswp/lib/index.js","../85b785412c3c676040050a5f5c5fb1","../base/dpttrf/lib/base.js","../base/dpttrf/lib/dpttrf.js","../base/dpttrf/lib/main.js","../base/dpttrf/lib/ndarray.js","../base/dpttrf/lib/index.js","../45c63784bd7e423732e87e15611fdd","../base/sge-trans/lib/base.js","../base/sge-trans/lib/sgetrans.js","../base/sge-trans/lib/main.js","../base/sge-trans/lib/ndarray.js","../base/sge-trans/lib/index.js","../02c1d046feafb154c12ef72f3ff325","../base/slacpy/lib/base.js","../base/slacpy/lib/slacpy.js","../base/slacpy/lib/main.js","../base/slacpy/lib/ndarray.js","../base/slacpy/lib/index.js","../f1a6386563a5a7c4cea2ac055f6bf9","../base/slaswp/lib/base.js","../base/slaswp/lib/slaswp.js","../base/slaswp/lib/main.js","../base/slaswp/lib/ndarray.js","../base/slaswp/lib/index.js","../25b8412b100bf5ce870fe321688538","../base/spttrf/lib/base.js","../base/spttrf/lib/spttrf.js","../base/spttrf/lib/main.js","../base/spttrf/lib/ndarray.js","../base/spttrf/lib/index.js","../6d10bcae7fce343c5fe762a1f1a940","../base/zlacgv/lib/ndarray.js","../base/zlacgv/lib/zlacgv.js","../base/zlacgv/lib/main.js","../base/zlacpy/lib/base.js","../base/zlacpy/lib/zlacpy.js","../base/zlacpy/lib/main.js","../base/zlacpy/lib/ndarray.js","../base/zlacpy/lib/index.js","../47a03638e04695565a8b3ab196ff61","../base/zlaset/lib/base.js","../base/zlaset/lib/zlaset.js","../base/zlaset/lib/main.js","../base/zlaset/lib/ndarray.js","../base/zlaset/lib/index.js","../9dc694036595a4df2fbfb83cc736a3","../base/zrot/lib/ndarray.js","../base/zrot/lib/zrot.js","../base/zrot/lib/main.js","../base/lib/index.js","../base/dlamch/lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a single-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - input array\n* @param {integer} strideCX - `cx` stride length\n* @param {NonNegativeInteger} offsetCX - starting `cx` index\n* @returns {Complex64Array} input array\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* clacgv( 3, cx, 1, 0 );\n*\n* var z = cx.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 1.0\n*\n* var im = imagf( z );\n* // returns -2.0\n*/\nfunction clacgv( N, cx, strideCX, offsetCX ) {\n\tvar cx32;\n\tvar ix;\n\tvar sx;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn cx;\n\t}\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tcx32 = reinterpret( cx, 0 );\n\n\t// Adjust the strides and offset:\n\tsx = strideCX * 2;\n\tix = ( offsetCX * 2 ) + 1; // index of the first imaginary component\n\n\t// Conjugate each element by negating the imaginary components...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tcx32[ ix ] = -cx32[ ix ];\n\t\tix += sx;\n\t}\n\treturn cx;\n}\n\n\n// EXPORTS //\n\nexport default clacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a single-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - input array\n* @param {integer} strideCX - `cx` stride length\n* @returns {Complex64Array} input array\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* clacgv( 3, cx, 1 );\n*\n* var z = cx.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 1.0\n*\n* var im = imagf( z );\n* // returns -2.0\n*/\nfunction clacgv( N, cx, strideCX ) {\n\treturn ndarray( N, cx, strideCX, stride2offset( N, strideCX ) );\n}\n\n\n// EXPORTS //\n\nexport default clacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport clacgv from './clacgv.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( clacgv, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default clacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 5.0, 6.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 5.0, 6.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 7.0, 8.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 1.0, 2.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tB[ ib+1 ] = A[ ia+1 ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 7.0, 8.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 5.0, 6.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 5.0, 6.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 7.0, 8.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 3.0, 4.0, 0.0, 0.0, 1.0, 2.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia + ( i1*strideA2 );\n\t\t\tjb = ib + ( i1*strideB2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tjb = ib;\n\t\tja = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 0.0, 0.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 0.0, 0.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 0.0, 0.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia;\n\t\t\tjb = ib;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tja = ia + ( i1*strideA1 );\n\t\tjb = ib + ( i1*strideB1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex64Array} `B`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 1.0\n*\n* v = imagf( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 3.0\n*\n* v = imagf( z );\n* // returns 4.0\n*\n* z = B.get( 2 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 5.0\n*\n* v = imagf( z );\n* // returns 6.0\n*\n* z = B.get( 3 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 7.0\n*\n* v = imagf( z );\n* // returns 8.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Complex64Array>\n*\n* var z = B.get( 0 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 1.0\n*\n* v = imagf( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 3.0\n*\n* v = imagf( z );\n* // returns 4.0\n*\n* z = B.get( 2 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 0.0\n*\n* v = imagf( z );\n* // returns 0.0\n*\n* z = B.get( 3 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 7.0\n*\n* v = imagf( z );\n* // returns 8.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 1.0\n*\n* v = imagf( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 0.0\n*\n* v = imagf( z );\n* // returns 0.0\n*\n* z = B.get( 2 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 5.0\n*\n* v = imagf( z );\n* // returns 6.0\n*\n* z = B.get( 3 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 7.0\n*\n* v = imagf( z );\n* // returns 8.0\n*/\nfunction clacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar viewA;\n\tvar viewB;\n\n\t// Reinterpret the input and output arrays as real-valued arrays of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\tviewB = reinterpret( B, 0 );\n\n\t// Adjust the strides and offsets accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\tstrideB1 *= 2;\n\tstrideB2 *= 2;\n\n\toffsetA *= 2;\n\toffsetB *= 2;\n\n\tif ( uplo === 'upper' ) {\n\t\tcopyUpper( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else if ( uplo === 'lower' ) {\n\t\tcopyLower( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else {\n\t\tcopyAll( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t}\n\treturn B;\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Complex64Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex64Array} `B`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 1.0\n*\n* v = imagf( z );\n* // returns 2.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 1.0\n*\n* v = imagf( z );\n* // returns 2.0\n*\n* z = B.get( 2 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 0.0\n*\n* v = imagf( z );\n* // returns 0.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 1.0\n*\n* v = imagf( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 0.0\n*\n* v = imagf( z );\n* // returns 0.0\n*/\nfunction clacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport clacpy from './clacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( clacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex64Array} `B`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 3.0\n*\n* v = imagf( z );\n* // returns 4.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 3.0\n*\n* v = imagf( z );\n* // returns 4.0\n*\n* z = B.get( 4 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 0.0\n*\n* v = imagf( z );\n* // returns 0.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 3.0\n*\n* v = imagf( z );\n* // returns 4.0\n*\n* z = B.get( 1 );\n* // returns <Complex64>\n*\n* v = realf( z );\n* // returns 0.0\n*\n* v = imagf( z );\n* // returns 0.0\n*/\nfunction clacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/clacpy\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n* import clacpy from '@stdlib/lapack/base/clacpy';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 1.0\n*\n* v = imagf( z );\n* // returns 2.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n* import clacpy from '@stdlib/lapack/base/clacpy';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>\n*\n* var v = realf( z );\n* // returns 3.0\n*\n* v = imagf( z );\n* // returns 4.0\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar clacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tclacpy = main;\n} else {\n\tclacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n\n// exports: { \"ndarray\": \"clacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/clacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\nimport loopOrder from '@stdlib/ndarray/base/nullary-loop-interchange-order';\nimport realf from '@stdlib/complex/float32/real';\nimport imagf from '@stdlib/complex/float32/imag';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Sets the diagonal of a single-precision complex floating-point matrix `A` to a specified value.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 3, 1.0, 2.0, A, 6, 2, 0 );\n* // A => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 3, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, 0.0, 0.0 ]\n*/\nfunction setDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA ) {\n\tvar sa;\n\tvar ia;\n\tvar i;\n\n\tsa = strideA1 + strideA2;\n\tia = offsetA;\n\tfor ( i = 0; i < min( M, N ); i++ ) {\n\t\tA[ ia ] = breal;\n\t\tA[ ia+1 ] = bimag;\n\t\tia += sa;\n\t}\n\treturn A;\n}\n\n/**\n* Sets all elements of a single-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setAll( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar da0;\n\tvar da1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\n\t// Set the pointer to the first indexed element:\n\tia = offsetA;\n\n\t// Fill the array with a scalar value...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tA[ ia ] = areal;\n\t\t\tA[ ia+1 ] = aimag;\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t}\n\t// Replace the diagonal:\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\n\treturn A;\n}\n\n/**\n* Sets the upper triangular/trapezoidal part of a single-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*/\nfunction setUpper( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n* Sets the lower triangular/trapezoidal part of a single-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setLower( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia + ( i1*strideA1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n\n// MAIN //\n\n/**\n* Sets elements of matrix `A` to specified values.\n*\n* @private\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64} alpha - value assigned to off-diagonal elements\n* @param {Complex64} beta - value assigned to diagonal elements\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex64Array} `A`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'all', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'upper', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 0.0\n*\n* im = imagf( z );\n* // returns 0.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'lower', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 0.0\n*\n* im = imagf( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*/\nfunction claset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar viewA;\n\tvar ar;\n\tvar ai;\n\tvar br;\n\tvar bi;\n\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\n\t// Adjust the strides and offset accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\n\toffsetA *= 2;\n\n\t// Decompose the scalars to real and imaginary components:\n\tar = realf( alpha );\n\tai = imagf( alpha );\n\tbr = realf( beta );\n\tbi = imagf( beta );\n\n\tif ( uplo === 'upper' ) {\n\t\tsetUpper( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else if ( uplo === 'lower' ) {\n\t\tsetLower( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else {\n\t\tsetAll( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a single-precision complex floating-point matrix to specified values.\n*\n* @param {string} order - storage layout of `A`\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64} alpha - value assigned to off-diagonal elements\n* @param {Complex64} beta - value assigned to diagonal elements\n* @param {Complex64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex64Array} `A`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'upper', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 0.0\n*\n* im = imagf( z );\n* // returns 0.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'lower', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 0.0\n*\n* im = imagf( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*/\nfunction claset( order, uplo, M, N, alpha, beta, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( uplo, M, N, alpha, beta, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport claset from './claset.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( claset, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a single-precision complex floating-point matrix to specified values.\n*\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64} alpha - value assigned to off-diagonal elements\n* @param {Complex64} beta - value assigned to diagonal elements\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex64Array} `A`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 5 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var A = new Complex64Array( 5 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'upper', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 0.0\n*\n* im = imagf( z );\n* // returns 0.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 5 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'lower', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 0.0\n*\n* im = imagf( z );\n* // returns 0.0\n*\n* z = A.get( 3 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns 1.0\n*\n* im = imagf( z );\n* // returns 2.0\n*/\nfunction claset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\treturn base( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to set the off-diagonal elements and the diagonal elements of a single-precision complex floating-point matrix to specified values.\n*\n* @module @stdlib/lapack/base/claset\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n* import claset from '@stdlib/lapack/base/claset';\n*\n* var A = new Complex64Array( 4 );\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n* import claset from '@stdlib/lapack/base/claset';\n*\n* var A = new Complex64Array( 5 );\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset.ndarray( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns 3.0\n*\n* var im = imagf( z );\n* // returns 4.0\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar claset;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tclaset = main;\n} else {\n\tclaset = tmp;\n}\n\n\n// EXPORTS //\n\nexport default claset;\n\n// exports: { \"ndarray\": \"claset.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/claset/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport f32 from '@stdlib/number/float64/base/to-float32';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\nimport realf from '@stdlib/complex/float32/real';\nimport imagf from '@stdlib/complex/float32/imag';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - first input array\n* @param {integer} strideCX - `cx` stride length\n* @param {NonNegativeInteger} offsetCX - starting `cx` index\n* @param {Complex64Array} cy - second input array\n* @param {integer} strideCY - `cy` stride length\n* @param {NonNegativeInteger} offsetCY - starting `cy` index\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex64} s - sine of the angle of rotation\n* @returns {Complex64Array} `cy`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var cy = new Complex64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex64( 0.3, 0.4 );\n*\n* crot( cx.length, cx, 1, 0, cy, 1, 0, 0.8, s );\n*\n* var z = cy.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns ~-1.1\n*\n* var im = imagf( z );\n* // returns ~-0.2\n*\n* z = cx.get( 0 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns ~0.8\n*\n* im = imagf( z );\n* // returns ~1.6\n*/\nfunction crot( N, cx, strideCX, offsetCX, cy, strideCY, offsetCY, c, s ) {\n\tvar viewX;\n\tvar viewY;\n\tvar sr;\n\tvar si;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar yr;\n\tvar yi;\n\tvar xr;\n\tvar xi;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn cy;\n\t}\n\tviewX = reinterpret( cx, 0 );\n\tviewY = reinterpret( cy, 0 );\n\n\tix = offsetCX * 2;\n\tiy = offsetCY * 2;\n\n\tsx = strideCX * 2;\n\tsy = strideCY * 2;\n\n\tsr = realf( s );\n\tsi = imagf( s );\n\n\tfor ( i = 0; i < N; i++ ) {\n\t\tyr = viewY[ iy ];\n\t\tyi = viewY[ iy+1 ];\n\t\txr = viewX[ ix ];\n\t\txi = viewX[ ix+1 ];\n\n\t\t// Compute tmp = c * cx[ ix ] + s * cy[ iy ]\n\t\tviewX[ ix ] = f32( f32( c*xr ) + f32( f32( sr*yr ) - f32( si*yi ) ) );\n\t\tviewX[ ix+1 ] = f32( f32( c*xi ) + f32( f32( sr*yi ) + f32( si*yr ) ) );\n\n\t\t// Compute cy[ iy ] = c * cy[ iy ] - conj(s) * cx[ ix ]\n\t\tviewY[ iy ] = f32( f32( c*yr ) - f32( f32( sr*xr ) + f32( si*xi ) ) );\n\t\tviewY[ iy+1 ] = f32( f32( c*yi ) - f32( f32( sr*xi ) - f32( si*xr ) ) );\n\n\t\tix += sx;\n\t\tiy += sy;\n\t}\n\treturn cy;\n}\n\n\n// EXPORTS //\n\nexport default crot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - first input array\n* @param {integer} strideCX - `cx` stride length\n* @param {Complex64Array} cy - second input array\n* @param {integer} strideCY - `cy` stride length\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex64} s - sine of the angle of rotation\n* @returns {Complex64Array} `cy`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import realf from '@stdlib/complex/float32/real';\n* import imagf from '@stdlib/complex/float32/imag';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var cy = new Complex64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex64( 0.3, 0.4 );\n*\n* crot( cx.length, cx, 1, cy, 1, 0.8, s );\n*\n* var z = cy.get( 0 );\n* // returns <Complex64>\n*\n* var re = realf( z );\n* // returns ~-1.1\n*\n* var im = imagf( z );\n* // returns ~-0.2\n*\n* z = cx.get( 0 );\n* // returns <Complex64>\n*\n* re = realf( z );\n* // returns ~0.8\n*\n* im = imagf( z );\n* // returns ~1.6\n*/\nfunction crot( N, cx, strideCX, cy, strideCY, c, s ) {\n\tvar ix = stride2offset( N, strideCX );\n\tvar iy = stride2offset( N, strideCY );\n\treturn ndarray( N, cx, strideCX, ix, cy, strideCY, iy, c, s );\n}\n\n\n// EXPORTS //\n\nexport default crot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport crot from './crot.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( crot, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default crot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float64Array} `out`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction dgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\tvar isrm;\n\tvar da0;\n\tvar da1;\n\tvar do0;\n\tvar do1;\n\tvar ia;\n\tvar io;\n\tvar i0;\n\tvar i1;\n\tvar S0;\n\tvar S1;\n\n\t// Note on variable naming convention: S#, da#, do#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Perform loop interchange based on the layout format of the output matrix...\n\tisrm = isRowMajor( [ strideO1, strideO2 ] );\n\tif ( isrm ) {\n\t\t// For row-major matrices, the last dimensions have the fastest changing indices...\n\t\tS0 = M;\n\t\tS1 = N;\n\t\tda0 = strideA1;                   // offset increment for innermost loop\n\t\tda1 = strideA2 - ( S0*strideA1 ); // offset increment for outermost loop\n\t\tdo0 = strideO2;\n\t\tdo1 = strideO1 - ( S0*strideO2 );\n\t} else {\n\t\t// For column-major matrices, the first dimensions have the fastest changing indices...\n\t\tS0 = N;\n\t\tS1 = M;\n\t\tda0 = strideA2;                   // offset increment for innermost loop\n\t\tda1 = strideA1 - ( S0*strideA2 ); // offset increment for outermost loop\n\t\tdo0 = strideO1;\n\t\tdo1 = strideO2 - ( S0*strideO1 );\n\t}\n\tia = offsetA;\n\tio = offsetO;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tout[ io ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tio += do0;\n\t\t}\n\t\tia += da1;\n\t\tio += do1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @param {string} order - storage layout\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} out - output matrix\n* @param {PositiveInteger} LDO - stride of the first dimension of `out` (a.k.a., leading dimension of the matrix `out`)\n* @throws {TypeError} first argument must be a valid order\n* @returns {Float64Array} `out`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction dgetrans( order, M, N, A, LDA, out, LDO ) {\n\tvar sa1;\n\tvar sa2;\n\tvar so1;\n\tvar so2;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tso1 = 1;\n\t\tso2 = LDO;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tso1 = LDO;\n\t\tso2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0, out, so1, so2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dgetrans from './dgetrans.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dgetrans, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float64Array} `out`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction dgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\treturn base( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO );\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to convert a matrix from row-major layout to column-major layout or vice versa.\n*\n* @module @stdlib/lapack/base/dge-trans\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dgetrans from '@stdlib/lapack/base/dge-trans';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dgetrans from '@stdlib/lapack/base/dge-trans';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans.ndarray( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dgetrans;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdgetrans = main;\n} else {\n\tdgetrans = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","export default '/home/runner/work/lapack/lapack/base/dge-trans/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 1.0, 4.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 3.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 3.0, 2.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 4.0, 1.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 1.0, 4.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 2.0, 3.0, 1.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 1.0, 0.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 0.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 3.0, 0.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 3.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 4.0, 0.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 2.0, 0.0, 1.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 0.0, 4.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 0.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 2.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 0.0, 1.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 0.0, 4.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 0.0, 3.0, 1.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction dlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( uplo === 'upper' ) {\n\t\treturn copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\tif ( uplo === 'lower' ) {\n\t\treturn copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\treturn copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction dlacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlacpy from './dlacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 0.0, 5.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 0.0, 4.0, 5.0 ]\n*/\nfunction dlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/dlacpy\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlacpy from '@stdlib/lapack/base/dlacpy';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlacpy from '@stdlib/lapack/base/dlacpy';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlacpy = main;\n} else {\n\tdlacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n\n// exports: { \"ndarray\": \"dlacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dlacpy/lib'","export default '/home/runner/work/lapack/lapack/base/dlassq/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isnan from '@stdlib/math/base/assert/is-nan';\nimport abs2 from '@stdlib/math/base/special/abs2';\nimport abs from '@stdlib/math/base/special/abs';\nimport sqrt from '@stdlib/math/base/special/sqrt';\n\n\n// VARIABLES //\n\nvar SBIG = 1.11137937474253874e-162;\nvar SSML = 4.49891379454319638e+161;\nvar TBIG = 1.99791907220223503e+146;\nvar TSML = 1.49166814624004135e-154;\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form.\n*\n* @private\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @param {Float64Array} out - output array\n* @param {integer} strideOut - stride length for `out`\n* @param {NonNegativeInteger} offsetOut - starting index for `out`\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq( 4, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut ) { // eslint-disable-line max-len\n\tvar notbig;\n\tvar abig;\n\tvar asml;\n\tvar amed;\n\tvar ymin;\n\tvar ymax;\n\tvar ax;\n\tvar ox;\n\tvar i;\n\n\tif ( isnan( scale ) || isnan( sumsq ) ) {\n\t\treturn out;\n\t}\n\tif ( sumsq === 0.0 ) {\n\t\tscale = 1.0;\n\t}\n\tif ( scale === 0.0 ) {\n\t\tscale = 1.0;\n\t\tsumsq = 0.0;\n\t}\n\tif ( N <= 0 ) {\n\t\tout[ offsetOut ] = scale;\n\t\tout[ offsetOut + strideOut ] = sumsq;\n\t\treturn out;\n\t}\n\t/*\n\t* Compute the sum of squares in 3 accumulators:\n\t*\n\t* -   `abig`: sums of squares scaled down to avoid overflow\n\t* -   `asml`: sums of squares scaled up to avoid underflow\n\t* -   `amed`: sums of squares that do not require scaling\n\t*\n\t* The thresholds and multipliers are\n\t*\n\t* -   `tbig`: values bigger than this are scaled down by `sbig`\n\t* -   `tsml`: values smaller than this are scaled up by `ssml`\n\t*/\n\tnotbig = true;\n\tasml = 0.0;\n\tamed = 0.0;\n\tabig = 0.0;\n\tox = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tax = abs( X[ ox ] );\n\t\tif ( ax > TBIG ) {\n\t\t\tabig += abs2( ax*SBIG );\n\t\t\tnotbig = false;\n\t\t} else if ( ax < TSML ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tasml += abs2( ax*SSML );\n\t\t\t}\n\t\t} else {\n\t\t\tamed += abs2( ax );\n\t\t}\n\t\tox += strideX;\n\t}\n\t// Put the existing sum of squares into one of the accumulators...\n\tif ( sumsq > 0.0 ) {\n\t\tax = scale * sqrt( sumsq );\n\t\tif ( ax > TBIG ) {\n\t\t\tif ( scale > 1.0 ) {\n\t\t\t\tscale *= SBIG;\n\t\t\t\tabig += scale * ( scale * sumsq );\n\t\t\t} else {\n\t\t\t\t// `sumsq > tbig^2` => `(sbig * (sbig * sumsq))` is representable\n\t\t\t\tabig += scale * ( scale * ( SBIG * ( SBIG*sumsq ) ) );\n\t\t\t}\n\t\t} else if ( ax < TSML ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tif ( scale < 1.0 ) {\n\t\t\t\t\tscale *= SSML;\n\t\t\t\t\tasml += scale * ( scale*sumsq );\n\t\t\t\t} else {\n\t\t\t\t\t// `sumsq < tsml^2` => `(ssml * (ssml * sumsq))` is representable\n\t\t\t\t\tasml += scale * ( scale * ( SSML * ( SSML*sumsq ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tamed += scale * ( scale*sumsq );\n\t\t}\n\t}\n\t// Combine `abig` and `amed` or `amed` and `asml` if more than one accumulator was used...\n\tif ( abig > 0.0 ) {\n\t\t// Combine `abig` and `amed` if `abig > 0`...\n\t\tif ( amed > 0.0 || isnan( amed ) ) {\n\t\t\tabig += ( amed*SBIG ) * SBIG;\n\t\t}\n\t\tout[ offsetOut ] = 1.0 / SBIG;\n\t\tout[ offsetOut + strideOut ] = abig;\n\t\treturn out;\n\t}\n\tif ( asml > 0.0 ) {\n\t\t// Combine `amed` and `asml` if `asml > 0`...\n\t\tif ( amed > 0.0 || isnan( amed ) ) {\n\t\t\tamed = sqrt( amed );\n\t\t\tasml = sqrt( asml ) / SSML;\n\t\t\tif ( asml > amed ) {\n\t\t\t\tymin = amed;\n\t\t\t\tymax = asml;\n\t\t\t} else {\n\t\t\t\tymin = asml;\n\t\t\t\tymax = amed;\n\t\t\t}\n\t\t\tscale = 1.0;\n\t\t\tsumsq = abs2( ymax ) * ( 1.0 + abs2( ymin/ymax ) );\n\t\t} else {\n\t\t\tscale = 1.0 / SSML;\n\t\t\tsumsq = asml;\n\t\t}\n\t\tout[ offsetOut ] = scale;\n\t\tout[ offsetOut + strideOut ] = sumsq;\n\t\treturn out;\n\t}\n\t// Otherwise all values are mid-range or zero...\n\tout[ offsetOut ] = 1.0;\n\tout[ offsetOut + strideOut ] = amed;\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Float64Array from '@stdlib/array/float64';\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form.\n*\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* var out = dlassq( 4, X, 1, 1.0, 0.0 );\n* // returns <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, scale, sumsq ) {\n\tvar out;\n\tvar ox;\n\n\tox = stride2offset( N, strideX );\n\tout = new Float64Array( 2 );\n\treturn base( N, X, strideX, ox, scale, sumsq, out, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlassq from './dlassq.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlassq, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @param {Float64Array} out - output array\n* @param {integer} strideOut - stride length for `out`\n* @param {NonNegativeInteger} offsetOut - starting index for `out`\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq( 4, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut ) {\n\treturn base( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut );\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to return an updated sum of squares represented in scaled form.\n*\n* @module @stdlib/lapack/base/dlassq\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlassq from '@stdlib/lapack/base/dlassq';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* var out = dlassq( X.length, X, 1, 1.0, 0.0 );\n* // returns <Float64Array>[ 1.0, 30.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlassq from '@stdlib/lapack/base/dlassq';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq.ndarray( X.length, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlassq;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlassq = main;\n} else {\n\tdlassq = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport floor from '@stdlib/math/base/special/floor';\nimport { ndarray as dswap } from '@stdlib/blas/base/dswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `dswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tdswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\t\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlaswp from './dlaswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack/base/dlaswp\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n* import dlaswp from '@stdlib/lapack/base/dlaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlaswp = main;\n} else {\n\tdlaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","export default '/home/runner/work/lapack/lapack/base/dlaswp/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @private\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tvar id;\n\tvar ie;\n\tvar v;\n\tvar i;\n\n\tif ( N === 0 ) {\n\t\treturn 0;\n\t}\n\tie = offsetE;\n\tid = offsetD;\n\n\t// Compute the `L * D * L^T` factorization of `A`...\n\tfor ( i = 0; i < N-1; i++ ) {\n\t\t// If `D[k] <= 0`, then the matrix is not positive definite...\n\t\tif ( D[ id ] <= 0.0 ) {\n\t\t\treturn i+1;\n\t\t}\n\t\t// Solve for E[k] and D[k+1]...\n\t\tv = E[ ie ];\n\t\tE[ ie ] = v / D[ id ];\n\n\t\tid += strideD;\n\t\tD[ id ] -= E[ ie ] * v;\n\n\t\tie += strideE;\n\t}\n\t// Check `D[k]` for positive definiteness...\n\tif ( D[ id ] <= 0.0 ) {\n\t\treturn N;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, E );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, E ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, 1, 0, E, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dpttrf from './dpttrf.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dpttrf, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A` using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, strideD, offsetD, E, strideE, offsetE );\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to compute the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @module @stdlib/lapack/base/dpttrf\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dpttrf from '@stdlib/lapack/base/dpttrf';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, E );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dpttrf from '@stdlib/lapack/base/dpttrf';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf.ndarray( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dpttrf;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdpttrf = main;\n} else {\n\tdpttrf = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","export default '/home/runner/work/lapack/lapack/base/dpttrf/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float32Array} `out`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction sgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\tvar isrm;\n\tvar da0;\n\tvar da1;\n\tvar do0;\n\tvar do1;\n\tvar ia;\n\tvar io;\n\tvar i0;\n\tvar i1;\n\tvar S0;\n\tvar S1;\n\n\t// Note on variable naming convention: S#, da#, do#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Perform loop interchange based on the layout format of the output matrix...\n\tisrm = isRowMajor( [ strideO1, strideO2 ] );\n\tif ( isrm ) {\n\t\t// For row-major matrices, the last dimensions have the fastest changing indices...\n\t\tS0 = M;\n\t\tS1 = N;\n\t\tda0 = strideA1;                   // offset increment for innermost loop\n\t\tda1 = strideA2 - ( S0*strideA1 ); // offset increment for outermost loop\n\t\tdo0 = strideO2;\n\t\tdo1 = strideO1 - ( S0*strideO2 );\n\t} else {\n\t\t// For column-major matrices, the first dimensions have the fastest changing indices...\n\t\tS0 = N;\n\t\tS1 = M;\n\t\tda0 = strideA2;                   // offset increment for innermost loop\n\t\tda1 = strideA1 - ( S0*strideA2 ); // offset increment for outermost loop\n\t\tdo0 = strideO1;\n\t\tdo1 = strideO2 - ( S0*strideO1 );\n\t}\n\tia = offsetA;\n\tio = offsetO;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tout[ io ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tio += do0;\n\t\t}\n\t\tia += da1;\n\t\tio += do1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @param {string} order - storage layout\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float32Array} out - output matrix\n* @param {PositiveInteger} LDO - stride of the first dimension of `out` (a.k.a., leading dimension of the matrix `out`)\n* @throws {TypeError} first argument must be a valid order\n* @returns {Float32Array} `out`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction sgetrans( order, M, N, A, LDA, out, LDO ) {\n\tvar sa1;\n\tvar sa2;\n\tvar so1;\n\tvar so2;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tso1 = 1;\n\t\tso2 = LDO;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tso1 = LDO;\n\t\tso2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0, out, so1, so2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport sgetrans from './sgetrans.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( sgetrans, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float32Array} `out`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction sgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\treturn base( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO );\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to convert a matrix from row-major layout to column-major layout or vice versa.\n*\n* @module @stdlib/lapack/base/sge-trans\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import sgetrans from '@stdlib/lapack/base/sge-trans';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import sgetrans from '@stdlib/lapack/base/sge-trans';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans.ndarray( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar sgetrans;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tsgetrans = main;\n} else {\n\tsgetrans = tmp;\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","export default '/home/runner/work/lapack/lapack/base/sge-trans/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 1.0, 4.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 3.0, 2.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 3.0, 2.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 4.0, 1.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 1.0, 4.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 2.0, 3.0, 1.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 1.0, 0.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 0.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 3.0, 0.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 3.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 4.0, 0.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 2.0, 0.0, 1.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 0.0, 4.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 0.0, 2.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 2.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 0.0, 1.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 0.0, 4.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 0.0, 3.0, 1.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction slacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( uplo === 'upper' ) {\n\t\treturn copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\tif ( uplo === 'lower' ) {\n\t\treturn copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\treturn copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float32Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction slacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport slacpy from './slacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( slacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 0.0, 5.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 0.0, 4.0, 5.0 ]\n*/\nfunction slacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/slacpy\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import slacpy from '@stdlib/lapack/base/slacpy';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import slacpy from '@stdlib/lapack/base/slacpy';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar slacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tslacpy = main;\n} else {\n\tslacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n\n// exports: { \"ndarray\": \"slacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/slacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport floor from '@stdlib/math/base/special/floor';\nimport { ndarray as sswap } from '@stdlib/blas/base/sswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float32Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction slaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `sswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tsswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\t\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float32Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Float32Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction slaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport slaswp from './slaswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( slaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float32Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction slaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack/base/slaswp\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n* import slaswp from '@stdlib/lapack/base/slaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar slaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tslaswp = main;\n} else {\n\tslaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n","export default '/home/runner/work/lapack/lapack/base/slaswp/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport f32 from '@stdlib/number/float64/base/to-float32';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @private\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tvar id;\n\tvar ie;\n\tvar v;\n\tvar i;\n\n\tif ( N === 0 ) {\n\t\treturn 0;\n\t}\n\tie = offsetE;\n\tid = offsetD;\n\n\t// Compute the `L * D * L^T` factorization of `A`...\n\tfor ( i = 0; i < N-1; i++ ) {\n\t\t// If `D[k] <= 0`, then the matrix is not positive definite...\n\t\tif ( D[ id ] <= 0.0 ) {\n\t\t\treturn i+1;\n\t\t}\n\t\t// Solve for E[k] and D[k+1]...\n\t\tv = E[ ie ];\n\t\tE[ ie ] = f32( v / D[ id ] );\n\n\t\tid += strideD;\n\t\tD[ id ] = f32( D[ id ] - f32( E[ ie ] * v ) );\n\n\t\tie += strideE;\n\t}\n\t// Check `D[k]` for positive definiteness...\n\tif ( D[ id ] <= 0.0 ) {\n\t\treturn N;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, E );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, E ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, 1, 0, E, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport spttrf from './spttrf.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( spttrf, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A` using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, strideD, offsetD, E, strideE, offsetE );\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to compute the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @module @stdlib/lapack/base/spttrf\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import spttrf from '@stdlib/lapack/base/spttrf';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, E );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import spttrf from '@stdlib/lapack/base/spttrf';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf.ndarray( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar spttrf;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tspttrf = main;\n} else {\n\tspttrf = tmp;\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","export default '/home/runner/work/lapack/lapack/base/spttrf/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a double-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - input array\n* @param {integer} strideZX - `zx` stride length\n* @param {NonNegativeInteger} offsetZX - starting `zx` index\n* @returns {Complex128Array} input array\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* zlacgv( 3, zx, 1, 0 );\n*\n* var z = zx.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 1.0\n*\n* var im = imag( z );\n* // returns -2.0\n*/\nfunction zlacgv( N, zx, strideZX, offsetZX ) {\n\tvar zx64;\n\tvar ix;\n\tvar sx;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn zx;\n\t}\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tzx64 = reinterpret( zx, 0 );\n\n\t// Adjust the strides and offset:\n\tsx = strideZX * 2;\n\tix = ( offsetZX * 2 ) + 1; // index of the first imaginary component\n\n\t// Conjugate each element by negating the imaginary components...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tzx64[ ix ] = -zx64[ ix ];\n\t\tix += sx;\n\t}\n\treturn zx;\n}\n\n\n// EXPORTS //\n\nexport default zlacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a double-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - input array\n* @param {integer} strideZX - `zx` stride length\n* @returns {Complex128Array} input array\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* zlacgv( 3, zx, 1 );\n*\n* var z = zx.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 1.0\n*\n* var im = imag( z );\n* // returns -2.0\n*/\nfunction zlacgv( N, zx, strideZX ) {\n\treturn ndarray( N, zx, strideZX, stride2offset( N, strideZX ) );\n}\n\n\n// EXPORTS //\n\nexport default zlacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zlacgv from './zlacgv.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlacgv, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 5.0, 6.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 5.0, 6.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 7.0, 8.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 1.0, 2.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tB[ ib+1 ] = A[ ia+1 ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 7.0, 8.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 5.0, 6.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 5.0, 6.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 7.0, 8.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 3.0, 4.0, 0.0, 0.0, 1.0, 2.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia + ( i1*strideA2 );\n\t\t\tjb = ib + ( i1*strideB2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tjb = ib;\n\t\tja = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 0.0, 0.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 0.0, 0.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 0.0, 0.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia;\n\t\t\tjb = ib;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tja = ia + ( i1*strideA1 );\n\t\tjb = ib + ( i1*strideB1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex128Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex128Array} `B`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 1.0\n*\n* v = imag( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 3.0\n*\n* v = imag( z );\n* // returns 4.0\n*\n* z = B.get( 2 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 5.0\n*\n* v = imag( z );\n* // returns 6.0\n*\n* z = B.get( 3 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 7.0\n*\n* v = imag( z );\n* // returns 8.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Complex128Array>\n*\n* var z = B.get( 0 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 1.0\n*\n* v = imag( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 3.0\n*\n* v = imag( z );\n* // returns 4.0\n*\n* z = B.get( 2 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 0.0\n*\n* v = imag( z );\n* // returns 0.0\n*\n* z = B.get( 3 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 7.0\n*\n* v = imag( z );\n* // returns 8.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 1.0\n*\n* v = imag( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 0.0\n*\n* v = imag( z );\n* // returns 0.0\n*\n* z = B.get( 2 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 5.0\n*\n* v = imag( z );\n* // returns 6.0\n*\n* z = B.get( 3 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 7.0\n*\n* v = imag( z );\n* // returns 8.0\n*/\nfunction zlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar viewA;\n\tvar viewB;\n\n\t// Reinterpret the input and output arrays as real-valued arrays of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\tviewB = reinterpret( B, 0 );\n\n\t// Adjust the strides and offsets accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\tstrideB1 *= 2;\n\tstrideB2 *= 2;\n\n\toffsetA *= 2;\n\toffsetB *= 2;\n\n\tif ( uplo === 'upper' ) {\n\t\tcopyUpper( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else if ( uplo === 'lower' ) {\n\t\tcopyLower( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else {\n\t\tcopyAll( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t}\n\treturn B;\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Complex128Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex128Array} `B`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 1.0\n*\n* v = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 1.0\n*\n* v = imag( z );\n* // returns 2.0\n*\n* z = B.get( 2 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 0.0\n*\n* v = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 1.0\n*\n* v = imag( z );\n* // returns 2.0\n*\n* z = B.get( 1 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 0.0\n*\n* v = imag( z );\n* // returns 0.0\n*/\nfunction zlacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zlacpy from './zlacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex128Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex128Array} `B`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 3.0\n*\n* v = imag( z );\n* // returns 4.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 3.0\n*\n* v = imag( z );\n* // returns 4.0\n*\n* z = B.get( 4 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 0.0\n*\n* v = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 3.0\n*\n* v = imag( z );\n* // returns 4.0\n*\n* z = B.get( 1 );\n* // returns <Complex128>\n*\n* v = real( z );\n* // returns 0.0\n*\n* v = imag( z );\n* // returns 0.0\n*/\nfunction zlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/zlacpy\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n* import zlacpy from '@stdlib/lapack/base/zlacpy';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 1.0\n*\n* v = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n* import zlacpy from '@stdlib/lapack/base/zlacpy';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>\n*\n* var v = real( z );\n* // returns 3.0\n*\n* v = imag( z );\n* // returns 4.0\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar zlacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlacpy = main;\n} else {\n\tzlacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n\n// exports: { \"ndarray\": \"zlacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/zlacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\nimport loopOrder from '@stdlib/ndarray/base/nullary-loop-interchange-order';\nimport real from '@stdlib/complex/float64/real';\nimport imag from '@stdlib/complex/float64/imag';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Sets the diagonal of a double-precision complex floating-point matrix `A` to a specified value.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 3, 1.0, 2.0, A, 6, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 3, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, 0.0, 0.0 ]\n*/\nfunction setDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA ) {\n\tvar sa;\n\tvar ia;\n\tvar i;\n\n\tsa = strideA1 + strideA2;\n\tia = offsetA;\n\tfor ( i = 0; i < min( M, N ); i++ ) {\n\t\tA[ ia ] = breal;\n\t\tA[ ia+1 ] = bimag;\n\t\tia += sa;\n\t}\n\treturn A;\n}\n\n/**\n* Sets all elements of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setAll( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar da0;\n\tvar da1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\n\t// Set the pointer to the first indexed element:\n\tia = offsetA;\n\n\t// Fill the array with a scalar value...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tA[ ia ] = areal;\n\t\t\tA[ ia+1 ] = aimag;\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t}\n\t// Replace the diagonal:\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\n\treturn A;\n}\n\n/**\n* Sets the upper triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*/\nfunction setUpper( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n* Sets the lower triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setLower( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia + ( i1*strideA1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n\n// MAIN //\n\n/**\n* Sets elements of matrix `A` to specified values.\n*\n* @private\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar viewA;\n\tvar ar;\n\tvar ai;\n\tvar br;\n\tvar bi;\n\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\n\t// Adjust the strides and offset accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\n\toffsetA *= 2;\n\n\t// Decompose the scalars to real and imaginary components:\n\tar = real( alpha );\n\tai = imag( alpha );\n\tbr = real( beta );\n\tbi = imag( beta );\n\n\tif ( uplo === 'upper' ) {\n\t\tsetUpper( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else if ( uplo === 'lower' ) {\n\t\tsetLower( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else {\n\t\tsetAll( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} order - storage layout of `A`\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'upper', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'lower', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( order, uplo, M, N, alpha, beta, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( uplo, M, N, alpha, beta, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zlaset from './zlaset.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlaset, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\treturn base( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to set the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @module @stdlib/lapack/base/zlaset\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n* import zlaset from '@stdlib/lapack/base/zlaset';\n*\n* var A = new Complex128Array( 4 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n* import zlaset from '@stdlib/lapack/base/zlaset';\n*\n* var A = new Complex128Array( 5 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset.ndarray( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar zlaset;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlaset = main;\n} else {\n\tzlaset = tmp;\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n\n// exports: { \"ndarray\": \"zlaset.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/zlaset/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\nimport real from '@stdlib/complex/float64/real';\nimport imag from '@stdlib/complex/float64/imag';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - first input array\n* @param {integer} strideX - `zx` stride length\n* @param {NonNegativeInteger} offsetX - starting `zx` index\n* @param {Complex128Array} zy - second input array\n* @param {integer} strideY - `zy` stride length\n* @param {NonNegativeInteger} offsetY - starting `zy` index\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex128} s - sine of the angle of rotation\n* @returns {Complex128Array} `zy`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var zy = new Complex128Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex128( 0.3, 0.4 );\n*\n* zrot( zx.length, zx, 1, 0, zy, 1, 0, 0.8, s );\n*\n* var z = zy.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns ~-1.1\n*\n* var im = imag( z );\n* // returns ~-0.2\n*\n* z = zx.get( 0 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns ~0.8\n*\n* im = imag( z );\n* // returns ~1.6\n*/\nfunction zrot( N, zx, strideX, offsetX, zy, strideY, offsetY, c, s ) {\n\tvar viewX;\n\tvar viewY;\n\tvar sr;\n\tvar si;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar yr;\n\tvar yi;\n\tvar xr;\n\tvar xi;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn zy;\n\t}\n\tviewX = reinterpret( zx, 0 );\n\tviewY = reinterpret( zy, 0 );\n\n\tix = offsetX * 2;\n\tiy = offsetY * 2;\n\n\tsx = strideX * 2;\n\tsy = strideY * 2;\n\n\tsr = real( s );\n\tsi = imag( s );\n\n\tfor ( i = 0; i < N; i++ ) {\n\t\tyr = viewY[ iy ];\n\t\tyi = viewY[ iy+1 ];\n\t\txr = viewX[ ix ];\n\t\txi = viewX[ ix+1 ];\n\n\t\t// Compute tmp = c * zx[ ix ] + s * zy[ iy ]\n\t\tviewX[ ix ] = ( c*xr ) + ( ( sr*yr ) - ( si*yi ) );\n\t\tviewX[ ix+1 ] = ( c*xi ) + ( ( sr*yi ) + ( si*yr ) );\n\n\t\t// Compute zy[ iy ] = c * zy[ iy ] - conj(s) * zx[ ix ]\n\t\tviewY[ iy ] = ( c*yr ) - ( ( sr*xr ) + ( si*xi ) );\n\t\tviewY[ iy+1 ] = ( c*yi ) - ( ( sr*xi ) - ( si*xr ) );\n\n\t\tix += sx;\n\t\tiy += sy;\n\t}\n\treturn zy;\n}\n\n\n// EXPORTS //\n\nexport default zrot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - first input array\n* @param {integer} strideX - `zx` stride length\n* @param {Complex128Array} zy - second input array\n* @param {integer} strideY - `zy` stride length\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex128} s - sine of the angle of rotation\n* @returns {Complex128Array} `zy`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var zy = new Complex128Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex128( 0.3, 0.4 );\n*\n* zrot( zx.length, zx, 1, zy, 1, 0.8, s );\n*\n* var z = zy.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns ~-1.1\n*\n* var im = imag( z );\n* // returns ~-0.2\n*\n* z = zx.get( 0 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns ~0.8\n*\n* im = imag( z );\n* // returns ~1.6\n*/\nfunction zrot( N, zx, strideX, zy, strideY, c, s ) {\n\tvar ix = stride2offset( N, strideX );\n\tvar iy = stride2offset( N, strideY );\n\treturn ndarray( N, zx, strideX, ix, zy, strideY, iy, c, s );\n}\n\n\n// EXPORTS //\n\nexport default zrot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zrot from './zrot.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zrot, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zrot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/*\n* When adding modules to the namespace, ensure that they are added in alphabetical order according to module name.\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-read-only-property';\n\n\n// MAIN //\n\n/**\n* Top-level namespace.\n*\n* @namespace ns\n*/\nvar ns = {};\n\n/**\n* @name clacgv\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/clacgv}\n*/\nimport clacgv from './../../base/clacgv';\nsetReadOnly( ns, 'clacgv', clacgv );\n\n/**\n* @name clacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/clacpy}\n*/\nimport clacpy from './../../base/clacpy';\nsetReadOnly( ns, 'clacpy', clacpy );\n\n/**\n* @name claset\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/claset}\n*/\nimport claset from './../../base/claset';\nsetReadOnly( ns, 'claset', claset );\n\n/**\n* @name crot\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/crot}\n*/\nimport crot from './../../base/crot';\nsetReadOnly( ns, 'crot', crot );\n\n/**\n* @name dgetrans\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dge-trans}\n*/\nimport dgetrans from './../../base/dge-trans';\nsetReadOnly( ns, 'dgetrans', dgetrans );\n\n/**\n* @name dlacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlacpy}\n*/\nimport dlacpy from './../../base/dlacpy';\nsetReadOnly( ns, 'dlacpy', dlacpy );\n\n/**\n* @name dlamch\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlamch}\n*/\nimport dlamch from './../../base/dlamch';\nsetReadOnly( ns, 'dlamch', dlamch );\n\n/**\n* @name dlassq\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlassq}\n*/\nimport dlassq from './../../base/dlassq';\nsetReadOnly( ns, 'dlassq', dlassq );\n\n/**\n* @name dlaswp\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlaswp}\n*/\nimport dlaswp from './../../base/dlaswp';\nsetReadOnly( ns, 'dlaswp', dlaswp );\n\n/**\n* @name dpttrf\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dpttrf}\n*/\nimport dpttrf from './../../base/dpttrf';\nsetReadOnly( ns, 'dpttrf', dpttrf );\n\n/**\n* @name sgetrans\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/sge-trans}\n*/\nimport sgetrans from './../../base/sge-trans';\nsetReadOnly( ns, 'sgetrans', sgetrans );\n\n/**\n* @name slacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/slacpy}\n*/\nimport slacpy from './../../base/slacpy';\nsetReadOnly( ns, 'slacpy', slacpy );\n\n/**\n* @name slaswp\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/slaswp}\n*/\nimport slaswp from './../../base/slaswp';\nsetReadOnly( ns, 'slaswp', slaswp );\n\n/**\n* @name spttrf\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/spttrf}\n*/\nimport spttrf from './../../base/spttrf';\nsetReadOnly( ns, 'spttrf', spttrf );\n\n/**\n* @name zlacgv\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zlacgv}\n*/\nimport zlacgv from './../../base/zlacgv';\nsetReadOnly( ns, 'zlacgv', zlacgv );\n\n/**\n* @name zlacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zlacpy}\n*/\nimport zlacpy from './../../base/zlacpy';\nsetReadOnly( ns, 'zlacpy', zlacpy );\n\n/**\n* @name zlaset\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zlaset}\n*/\nimport zlaset from './../../base/zlaset';\nsetReadOnly( ns, 'zlaset', zlaset );\n\n/**\n* @name zrot\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zrot}\n*/\nimport zrot from './../../base/zrot';\nsetReadOnly( ns, 'zrot', zrot );\n\n\n// EXPORTS //\n\nexport default ns;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport FLOAT64_EPS from '@stdlib/constants/float64/eps';\nimport FLOAT64_SMALLEST_NORMAL from '@stdlib/constants/float64/smallest-normal';\nimport FLOAT64_MIN_EXPONENT from '@stdlib/constants/float64/min-base2-exponent';\nimport FLOAT64_MAX_EXPONENT from '@stdlib/constants/float64/max-base2-exponent';\nimport FLOAT64_MAX from '@stdlib/constants/float64/max';\nimport FLOAT64_PRECISION from '@stdlib/constants/float64/precision';\nimport lowercase from '@stdlib/string/base/lowercase';\n\n\n// VARIABLES //\n\nvar RADIX = 2.0;\n\n\n// MAIN //\n\n/**\n* Determines double-precision floating-point machine parameters.\n*\n* ## Notes\n*\n* -   The `cmach` parameter is a string which specifies the double-precision machine parameter to be returned. The function recognizes the following characters:\n*\n*     -   `'E'`/`'e'`: (eps) relative machine precision.\n*     -   `'S'`/`'s'`: (sfmin) safe minimum such that `1/sfmin` does not overflow.\n*     -   `'B'`/`'b'`: (base) base of the machine (also known as the floating-point radix).\n*     -   `'P'`/`'p'`: (prec) `eps*base`.\n*     -   `'N'`/`'n'`: (t) number of (base) digits in the mantissa.\n*     -   `'R'`/`'r'`: (rnd) `1.0` when rounding occurs in addition and `0.0` otherwise.\n*     -   `'M'`/`'m'`: (emin) minimum exponent before (gradual) underflow.\n*     -   `'U'`/`'u'`: (rmin) underflow threshold.\n*     -   `'L'`/`'l'`: (emax) largest exponent before overflow.\n*     -   `'O'`/`'o'`: (rmax) overflow threshold.\n*\n* @param {string} cmach - specifies the value to be returned\n* @returns {number} machine parameter\n*\n* @example\n* var out = dlamch( 'E' );\n* // returns ~1.1102230246251565e-016\n*\n* out = dlamch( 'S' );\n* // returns ~2.2250738585072014e-308\n*\n* out = dlamch( 'B' );\n* // returns 2.0\n*/\nfunction dlamch( cmach ) {\n\tcmach = lowercase( cmach.charAt( 0 ) );\n\tif ( cmach === 'e' ) {\n\t\treturn FLOAT64_EPS * 0.5;\n\t}\n\tif ( cmach === 's' ) {\n\t\treturn FLOAT64_SMALLEST_NORMAL;\n\t}\n\tif ( cmach === 'b' ) {\n\t\treturn RADIX;\n\t}\n\tif ( cmach === 'p' ) {\n\t\treturn FLOAT64_EPS * 0.5 * RADIX;\n\t}\n\tif ( cmach === 'n' ) {\n\t\treturn FLOAT64_PRECISION;\n\t}\n\tif ( cmach === 'r' ) {\n\t\treturn 1.0;\n\t}\n\tif ( cmach === 'm' ) {\n\t\treturn FLOAT64_MIN_EXPONENT + 1;\n\t}\n\tif ( cmach === 'u' ) {\n\t\treturn FLOAT64_SMALLEST_NORMAL;\n\t}\n\tif ( cmach === 'l' ) {\n\t\treturn FLOAT64_MAX_EXPONENT + 1;\n\t}\n\tif ( cmach === 'o' ) {\n\t\treturn FLOAT64_MAX;\n\t}\n\treturn 0.0;\n}\n\n\n// EXPORTS //\n\nexport default dlamch;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/*\n* When adding modules to the namespace, ensure that they are added in alphabetical order according to module name.\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-read-only-property';\n\n\n// MAIN //\n\n/**\n* Top-level namespace.\n*\n* @namespace ns\n*/\nvar ns = {};\n\n/**\n* @name base\n* @memberof ns\n* @readonly\n* @type {Namespace}\n* @see {@link module:@stdlib/lapack/base}\n*/\nimport base from './../base';\nsetReadOnly( ns, 'base', base );\n\n\n// EXPORTS //\n\nexport default ns;\n"],"names":["clacgv","N","cx","strideCX","offsetCX","cx32","ix","sx","i","reinterpret","ndarray","stride2offset","setReadOnly","clacpy","uplo","M","A","strideA1","strideA2","offsetA","B","strideB1","strideB2","offsetB","viewA","viewB","ia","ib","i0","i1","ja","jb","isRowMajor","min","copyUpper","copyLower","da0","da1","db0","db1","sh","S0","S1","sa","sb","o","loopOrder","sy","copyAll","order","LDA","LDB","sa1","sa2","sb1","sb2","isLayout","TypeError","format","isColumnMajor","RangeError","base","tmp","tryRequire","join","require$$0","clacpy$1","isError","main","setDiagonal","breal","bimag","claset","alpha","beta","ar","ai","br","bi","realf","imagf","areal","aimag","idx","setUpper","setLower","setAll","claset$1","crot","cy","strideCY","offsetCY","c","s","viewX","viewY","sr","si","iy","yr","yi","xr","xi","f32","dgetrans","out","strideO1","strideO2","offsetO","do0","do1","io","LDO","so1","so2","dgetrans$1","dlacpy","dlacpy$1","SBIG","SSML","TBIG","TSML","dlassq","X","strideX","offsetX","scale","sumsq","strideOut","offsetOut","notbig","abig","asml","amed","ymin","ymax","ax","ox","isnan","abs","abs2","sqrt","Float64Array","dlassq$1","BLOCK_SIZE","dlaswp","k1","k2","inck","IPIV","strideIPIV","offsetIPIV","nrows","n32","row","ia1","ia2","ip","j","k","n","dswap","floor","incx","inc","max","dlaswp$1","dpttrf","D","strideD","offsetD","E","strideE","offsetE","id","ie","v","dpttrf$1","sgetrans","sgetrans$1","slacpy","slacpy$1","slaswp","sswap","slaswp$1","spttrf","spttrf$1","zlacgv","zx","strideZX","offsetZX","zx64","zlacpy","zlacpy$1","zlaset","real","imag","zlaset$1","zrot","zy","strideY","offsetY","ns","cmach","lowercase","charAt","FLOAT64_EPS","FLOAT64_SMALLEST_NORMAL","FLOAT64_PRECISION","FLOAT64_MIN_EXPONENT","FLOAT64_MAX_EXPONENT","FLOAT64_MAX"],"mappings":"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"}