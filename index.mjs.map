{"version":3,"file":"index.mjs","sources":["../base/dlacpy/lib/base.js","../base/dlacpy/lib/dlacpy.js","../base/dlacpy/lib/main.js","../base/dlacpy/lib/ndarray.js","../base/dlacpy/lib/index.js","../cd5ad8f6a6493ddafac57fa7b0c6b6","../base/dlassq/lib/base.js","../base/dlassq/lib/dlassq.js","../base/dlassq/lib/main.js","../base/dlassq/lib/ndarray.js","../base/dlassq/lib/index.js","../f3ace61b54895d9abfe9078e7622ed","../base/dlaswp/lib/base.js","../base/dlaswp/lib/dlaswp.js","../base/dlaswp/lib/main.js","../base/dlaswp/lib/ndarray.js","../base/dlaswp/lib/index.js","../016e780b170ec952a4e9175b181126","../base/dpttrf/lib/base.js","../base/dpttrf/lib/dpttrf.js","../base/dpttrf/lib/main.js","../base/dpttrf/lib/ndarray.js","../base/dpttrf/lib/index.js","../59fb9368915227a545f91355cd6e1e","../base/slacpy/lib/base.js","../base/slacpy/lib/slacpy.js","../base/slacpy/lib/main.js","../base/slacpy/lib/ndarray.js","../base/slacpy/lib/index.js","../f1836f719810ace940c174c2ab353d","../base/spttrf/lib/base.js","../base/spttrf/lib/spttrf.js","../base/spttrf/lib/main.js","../base/spttrf/lib/ndarray.js","../base/spttrf/lib/index.js","../097109a973ab66e02a21bb4b0e958b","../base/lib/index.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 1.0, 4.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 3.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 3.0, 2.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 4.0, 1.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 1.0, 4.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 2.0, 3.0, 1.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 1.0, 0.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 0.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 3.0, 0.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 3.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 4.0, 0.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 2.0, 0.0, 1.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 0.0, 4.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 0.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 2.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 0.0, 1.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 0.0, 4.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 0.0, 3.0, 1.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction dlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( uplo === 'upper' ) {\n\t\treturn copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\tif ( uplo === 'lower' ) {\n\t\treturn copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\treturn copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction dlacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( order === 'column-major' ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlacpy from './dlacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 0.0, 5.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 0.0, 4.0, 5.0 ]\n*/\nfunction dlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/dlacpy\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlacpy from '@stdlib/lapack/base/dlacpy';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlacpy from '@stdlib/lapack/base/dlacpy';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlacpy = main;\n} else {\n\tdlacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n\n// exports: { \"ndarray\": \"dlacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dlacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isnan from '@stdlib/math/base/assert/is-nan';\nimport abs2 from '@stdlib/math/base/special/abs2';\nimport abs from '@stdlib/math/base/special/abs';\nimport sqrt from '@stdlib/math/base/special/sqrt';\n\n\n// VARIABLES //\n\nvar SBIG = 1.11137937474253874e-162;\nvar SSML = 4.49891379454319638e+161;\nvar TBIG = 1.99791907220223503e+146;\nvar TSML = 1.49166814624004135e-154;\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form.\n*\n* @private\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @param {Float64Array} out - output array\n* @param {integer} strideOut - stride length for `out`\n* @param {NonNegativeInteger} offsetOut - starting index for `out`\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq( 4, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut ) { // eslint-disable-line max-len\n\tvar notbig;\n\tvar abig;\n\tvar asml;\n\tvar amed;\n\tvar ymin;\n\tvar ymax;\n\tvar ax;\n\tvar ox;\n\tvar i;\n\n\tif ( isnan( scale ) || isnan( sumsq ) ) {\n\t\treturn out;\n\t}\n\tif ( sumsq === 0.0 ) {\n\t\tscale = 1.0;\n\t}\n\tif ( scale === 0.0 ) {\n\t\tscale = 1.0;\n\t\tsumsq = 0.0;\n\t}\n\tif ( N <= 0 ) {\n\t\tout[ offsetOut ] = scale;\n\t\tout[ offsetOut + strideOut ] = sumsq;\n\t\treturn out;\n\t}\n\t/*\n\t* Compute the sum of squares in 3 accumulators:\n\t*\n\t* -   `abig`: sums of squares scaled down to avoid overflow\n\t* -   `asml`: sums of squares scaled up to avoid underflow\n\t* -   `amed`: sums of squares that do not require scaling\n\t*\n\t* The thresholds and multipliers are\n\t*\n\t* -   `tbig`: values bigger than this are scaled down by `sbig`\n\t* -   `tsml`: values smaller than this are scaled up by `ssml`\n\t*/\n\tnotbig = true;\n\tasml = 0.0;\n\tamed = 0.0;\n\tabig = 0.0;\n\tox = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tax = abs( X[ ox ] );\n\t\tif ( ax > TBIG ) {\n\t\t\tabig += abs2( ax*SBIG );\n\t\t\tnotbig = false;\n\t\t} else if ( ax < TSML ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tasml += abs2( ax*SSML );\n\t\t\t}\n\t\t} else {\n\t\t\tamed += abs2( ax );\n\t\t}\n\t\tox += strideX;\n\t}\n\t// Put the existing sum of squares into one of the accumulators...\n\tif ( sumsq > 0.0 ) {\n\t\tax = scale * sqrt( sumsq );\n\t\tif ( ax > TBIG ) {\n\t\t\tif ( scale > 1.0 ) {\n\t\t\t\tscale *= SBIG;\n\t\t\t\tabig += scale * ( scale * sumsq );\n\t\t\t} else {\n\t\t\t\t// `sumsq > tbig^2` => `(sbig * (sbig * sumsq))` is representable\n\t\t\t\tabig += scale * ( scale * ( SBIG * ( SBIG*sumsq ) ) );\n\t\t\t}\n\t\t} else if ( ax < TSML ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tif ( scale < 1.0 ) {\n\t\t\t\t\tscale *= SSML;\n\t\t\t\t\tasml += scale * ( scale*sumsq );\n\t\t\t\t} else {\n\t\t\t\t\t// `sumsq < tsml^2` => `(ssml * (ssml * sumsq))` is representable\n\t\t\t\t\tasml += scale * ( scale * ( SSML * ( SSML*sumsq ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tamed += scale * ( scale*sumsq );\n\t\t}\n\t}\n\t// Combine `abig` and `amed` or `amed` and `asml` if more than one accumulator was used...\n\tif ( abig > 0.0 ) {\n\t\t// Combine `abig` and `amed` if `abig > 0`...\n\t\tif ( amed > 0.0 || isnan( amed ) ) {\n\t\t\tabig += ( amed*SBIG ) * SBIG;\n\t\t}\n\t\tout[ offsetOut ] = 1.0 / SBIG;\n\t\tout[ offsetOut + strideOut ] = abig;\n\t\treturn out;\n\t}\n\tif ( asml > 0.0 ) {\n\t\t// Combine `amed` and `asml` if `asml > 0`...\n\t\tif ( amed > 0.0 || isnan( amed ) ) {\n\t\t\tamed = sqrt( amed );\n\t\t\tasml = sqrt( asml ) / SSML;\n\t\t\tif ( asml > amed ) {\n\t\t\t\tymin = amed;\n\t\t\t\tymax = asml;\n\t\t\t} else {\n\t\t\t\tymin = asml;\n\t\t\t\tymax = amed;\n\t\t\t}\n\t\t\tscale = 1.0;\n\t\t\tsumsq = abs2( ymax ) * ( 1.0 + abs2( ymin/ymax ) );\n\t\t} else {\n\t\t\tscale = 1.0 / SSML;\n\t\t\tsumsq = asml;\n\t\t}\n\t\tout[ offsetOut ] = scale;\n\t\tout[ offsetOut + strideOut ] = sumsq;\n\t\treturn out;\n\t}\n\t// Otherwise all values are mid-range or zero...\n\tout[ offsetOut ] = 1.0;\n\tout[ offsetOut + strideOut ] = amed;\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Float64Array from '@stdlib/array/float64';\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form.\n*\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* var out = dlassq( 4, X, 1, 1.0, 0.0 );\n* // returns <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, scale, sumsq ) {\n\tvar out;\n\tvar ox;\n\n\tox = stride2offset( N, strideX );\n\tout = new Float64Array( 2 );\n\treturn base( N, X, strideX, ox, scale, sumsq, out, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlassq from './dlassq.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlassq, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @param {Float64Array} out - output array\n* @param {integer} strideOut - stride length for `out`\n* @param {NonNegativeInteger} offsetOut - starting index for `out`\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq( 4, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut ) {\n\treturn base( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut );\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to return an updated sum of squares represented in scaled form.\n*\n* @module @stdlib/lapack/base/dlassq\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlassq from '@stdlib/lapack/base/dlassq';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* var out = dlassq( X.length, X, 1, 1.0, 0.0 );\n* // returns <Float64Array>[ 1.0, 30.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlassq from '@stdlib/lapack/base/dlassq';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq.ndarray( X.length, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlassq;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlassq = main;\n} else {\n\tdlassq = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","export default '/home/runner/work/lapack/lapack/base/dlassq/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport floor from '@stdlib/math/base/special/floor';\nimport { ndarray as dswap } from '@stdlib/blas/base/dswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `dswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tdswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\t\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport max from '@stdlib/math/base/special/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( order === 'row-major' && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( order === 'column-major' ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlaswp from './dlaswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack/base/dlaswp\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n* import dlaswp from '@stdlib/lapack/base/dlaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlaswp = main;\n} else {\n\tdlaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","export default '/home/runner/work/lapack/lapack/base/dlaswp/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @private\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tvar id;\n\tvar ie;\n\tvar v;\n\tvar i;\n\n\tif ( N === 0 ) {\n\t\treturn 0;\n\t}\n\tie = offsetE;\n\tid = offsetD;\n\n\t// Compute the `L * D * L^T` factorization of `A`...\n\tfor ( i = 0; i < N-1; i++ ) {\n\t\t// If `D[k] <= 0`, then the matrix is not positive definite...\n\t\tif ( D[ id ] <= 0.0 ) {\n\t\t\treturn i+1;\n\t\t}\n\t\t// Solve for E[k] and D[k+1]...\n\t\tv = E[ ie ];\n\t\tE[ ie ] = v / D[ id ];\n\n\t\tid += strideD;\n\t\tD[ id ] -= E[ ie ] * v;\n\n\t\tie += strideE;\n\t}\n\t// Check `D[k]` for positive definiteness...\n\tif ( D[ id ] <= 0.0 ) {\n\t\treturn N;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, E );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, E ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, 1, 0, E, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dpttrf from './dpttrf.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dpttrf, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A` using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, strideD, offsetD, E, strideE, offsetE );\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to compute the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @module @stdlib/lapack/base/dpttrf\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dpttrf from '@stdlib/lapack/base/dpttrf';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, E );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dpttrf from '@stdlib/lapack/base/dpttrf';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf.ndarray( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dpttrf;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdpttrf = main;\n} else {\n\tdpttrf = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","export default '/home/runner/work/lapack/lapack/base/dpttrf/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 1.0, 4.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 3.0, 2.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 3.0, 2.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 4.0, 1.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 1.0, 4.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 2.0, 3.0, 1.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 1.0, 0.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 0.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 3.0, 0.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 3.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 4.0, 0.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 2.0, 0.0, 1.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 0.0, 4.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 0.0, 2.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 2.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 0.0, 1.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 0.0, 4.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 0.0, 3.0, 1.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction slacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( uplo === 'upper' ) {\n\t\treturn copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\tif ( uplo === 'lower' ) {\n\t\treturn copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\treturn copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float32Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction slacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( order === 'column-major' ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport slacpy from './slacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( slacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 0.0, 5.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 0.0, 4.0, 5.0 ]\n*/\nfunction slacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/slacpy\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import slacpy from '@stdlib/lapack/base/slacpy';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import slacpy from '@stdlib/lapack/base/slacpy';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar slacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tslacpy = main;\n} else {\n\tslacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n\n// exports: { \"ndarray\": \"slacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/slacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport f32 from '@stdlib/number/float64/base/to-float32';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @private\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tvar id;\n\tvar ie;\n\tvar v;\n\tvar i;\n\n\tif ( N === 0 ) {\n\t\treturn 0;\n\t}\n\tie = offsetE;\n\tid = offsetD;\n\n\t// Compute the `L * D * L^T` factorization of `A`...\n\tfor ( i = 0; i < N-1; i++ ) {\n\t\t// If `D[k] <= 0`, then the matrix is not positive definite...\n\t\tif ( D[ id ] <= 0.0 ) {\n\t\t\treturn i+1;\n\t\t}\n\t\t// Solve for E[k] and D[k+1]...\n\t\tv = E[ ie ];\n\t\tE[ ie ] = f32( v / D[ id ] );\n\n\t\tid += strideD;\n\t\tD[ id ] = f32( D[ id ] - f32( E[ ie ] * v ) );\n\n\t\tie += strideE;\n\t}\n\t// Check `D[k]` for positive definiteness...\n\tif ( D[ id ] <= 0.0 ) {\n\t\treturn N;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, E );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, E ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, 1, 0, E, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport spttrf from './spttrf.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( spttrf, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A` using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, strideD, offsetD, E, strideE, offsetE );\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to compute the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @module @stdlib/lapack/base/spttrf\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import spttrf from '@stdlib/lapack/base/spttrf';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, E );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import spttrf from '@stdlib/lapack/base/spttrf';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf.ndarray( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar spttrf;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tspttrf = main;\n} else {\n\tspttrf = tmp;\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","export default '/home/runner/work/lapack/lapack/base/spttrf/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/*\n* When adding modules to the namespace, ensure that they are added in alphabetical order according to module name.\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-read-only-property';\n\n\n// MAIN //\n\n/**\n* Top-level namespace.\n*\n* @namespace ns\n*/\nvar ns = {};\n\n/**\n* @name dlacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlacpy}\n*/\nimport dlacpy from './../../base/dlacpy';\nsetReadOnly( ns, 'dlacpy', dlacpy );\n\n/**\n* @name dlassq\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlassq}\n*/\nimport dlassq from './../../base/dlassq';\nsetReadOnly( ns, 'dlassq', dlassq );\n\n/**\n* @name dlaswp\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlaswp}\n*/\nimport dlaswp from './../../base/dlaswp';\nsetReadOnly( ns, 'dlaswp', dlaswp );\n\n/**\n* @name dpttrf\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dpttrf}\n*/\nimport dpttrf from './../../base/dpttrf';\nsetReadOnly( ns, 'dpttrf', dpttrf );\n\n/**\n* @name slacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/slacpy}\n*/\nimport slacpy from './../../base/slacpy';\nsetReadOnly( ns, 'slacpy', slacpy );\n\n/**\n* @name spttrf\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/spttrf}\n*/\nimport spttrf from './../../base/spttrf';\nsetReadOnly( ns, 'spttrf', spttrf );\n\n\n// EXPORTS //\n\nexport default ns;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/*\n* When adding modules to the namespace, ensure that they are added in alphabetical order according to module name.\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-read-only-property';\n\n\n// MAIN //\n\n/**\n* Top-level namespace.\n*\n* @namespace ns\n*/\nvar ns = {};\n\n/**\n* @name base\n* @memberof ns\n* @readonly\n* @type {Namespace}\n* @see {@link module:@stdlib/lapack/base}\n*/\nimport base from './../base';\nsetReadOnly( ns, 'base', base );\n\n\n// EXPORTS //\n\nexport default ns;\n"],"names":["dlacpy","uplo","M","N","A","strideA1","strideA2","offsetA","B","strideB1","strideB2","offsetB","ia","ib","i0","i1","isRowMajor","min","copyUpper","copyLower","da0","da1","db0","db1","sh","S0","S1","sa","sb","o","loopOrder","sx","sy","copyAll","order","LDA","LDB","sa1","sa2","sb1","sb2","isLayout","TypeError","format","RangeError","base","setReadOnly","tmp","tryRequire","join","require$$0","dlacpy$1","isError","main","SBIG","SSML","TBIG","TSML","dlassq","X","strideX","offsetX","scale","sumsq","out","strideOut","offsetOut","notbig","abig","asml","amed","ymin","ymax","ax","ox","i","isnan","abs","abs2","sqrt","stride2offset","Float64Array","dlassq$1","BLOCK_SIZE","dlaswp","k1","k2","inck","IPIV","strideIPIV","offsetIPIV","nrows","n32","row","ia1","ia2","ip","j","k","n","dswap","floor","incx","inc","io","max","dlaswp$1","dpttrf","D","strideD","offsetD","E","strideE","offsetE","id","ie","v","dpttrf$1","slacpy","slacpy$1","spttrf","f32","spttrf$1","ns"],"mappings":";;8zIA6bA,SAASA,EAAQC,EAAMC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GACnF,MAAc,UAATV,EAhMN,SAAoBC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAChF,IAAIC,EACAC,EACAC,EACAC,EAIJ,GAFAH,EAAKL,EACLM,EAAKF,EACAK,EAAY,CAAEX,EAAUC,IAAe,CAC3C,IAAMS,EAAK,EAAGA,EAAKb,EAAGa,IAAO,CAC5B,IAAMD,EAAKC,EAAID,EAAKX,EAAGW,IACtBN,EAAGK,EAAIC,EAAGJ,GAAcN,EAAGQ,EAAIE,EAAGR,GAEnCM,GAAMP,EACNQ,GAAMJ,CACN,CACD,OAAOD,CACP,CACD,IAAMO,EAAK,EAAGA,EAAKZ,EAAGY,IAAO,CAC5B,IAAMD,EAAK,EAAGA,GAAMG,EAAKF,EAAIb,EAAE,GAAKY,IACnCN,EAAGK,EAAIC,EAAGL,GAAcL,EAAGQ,EAAIE,EAAGT,GAEnCO,GAAMN,EACNO,GAAMH,CACN,CACD,OAAOF,CACR,CAuKSU,CAAWhB,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAElE,UAATV,EA/EN,SAAoBC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAChF,IAAIC,EACAC,EACAC,EACAC,EAIJ,GAFAH,EAAKL,EACLM,EAAKF,EACAK,EAAY,CAAEX,EAAUC,IAAe,CAC3C,IAAMS,EAAK,EAAGA,EAAKb,EAAGa,IAAO,CAC5B,IAAMD,EAAK,EAAGA,GAAMG,EAAKF,EAAIZ,EAAE,GAAKW,IACnCN,EAAGK,EAAIC,EAAGJ,GAAcN,EAAGQ,EAAIE,EAAGR,GAEnCM,GAAMP,EACNQ,GAAMJ,CACN,CACD,OAAOD,CACP,CACD,IAAMO,EAAK,EAAGA,EAAKZ,EAAGY,IAAO,CAC5B,IAAMD,EAAKC,EAAID,EAAKZ,EAAGY,IACtBN,EAAGK,EAAIC,EAAGL,GAAcL,EAAGQ,EAAIE,EAAGT,GAEnCO,GAAMN,EACNO,GAAMH,CACN,CACD,OAAOF,CACR,CAsDSW,CAAWjB,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GA3UjF,SAAkBT,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAC9E,IAAIS,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAhB,EACAC,EACAC,EACAC,EACAc,EAqBJ,IAjBAL,GADAK,EAAIC,EAAW,CAAE5B,EAAGC,GAAK,CAAEE,EAAUC,GAAY,CAAEG,EAAUC,KACtDc,GACPG,EAAKE,EAAEE,GACPH,EAAKC,EAAEG,GAGPP,EAAKD,EAAI,GACTE,EAAKF,EAAI,GACTJ,EAAMO,EAAI,GACVN,EAAMM,EAAI,GAAQF,EAAGE,EAAG,GACxBL,EAAMM,EAAI,GACVL,EAAMK,EAAI,GAAQH,EAAGG,EAAG,GAGxBhB,EAAKL,EACLM,EAAKF,EAGCI,EAAK,EAAGA,EAAKW,EAAIX,IAAO,CAC7B,IAAMD,EAAK,EAAGA,EAAKW,EAAIX,IACtBN,EAAGK,GAAOT,EAAGQ,GACbA,GAAMQ,EACNP,GAAMS,EAEPV,GAAMS,EACNR,GAAMU,CACN,CACD,OAAOf,CACR,CAgSQyB,CAAS/B,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,EAC9E,CC7XA,SAASX,EAAQkC,EAAOjC,EAAMC,EAAGC,EAAGC,EAAG+B,EAAK3B,EAAG4B,GAC9C,IAAIC,EACAC,EACAC,EACAC,EACJ,IAAMC,EAAUP,GACf,MAAM,IAAIQ,UAAWC,EAAQ,uEAAwET,IAEtG,GAAe,iBAAVA,EACJG,EAAM,EACNC,EAAMH,EACNI,EAAM,EACNC,EAAMJ,MACA,CACN,GAAKD,EAAMhC,EACV,MAAM,IAAIyC,WAAYD,EAAQ,qFAAsFxC,EAAGgC,IAExH,GAAKC,EAAMjC,EACV,MAAM,IAAIyC,WAAYD,EAAQ,sFAAuFxC,EAAGiC,IAEzHC,EAAMF,EACNG,EAAM,EACNC,EAAMH,EACNI,EAAM,CACN,CACD,OAAOK,EAAM5C,EAAMC,EAAGC,EAAGC,EAAGiC,EAAKC,EAAK,EAAG9B,EAAG+B,EAAKC,EAAK,EACvD,CCrEAM,EAAA9C,EAAA,WCyCA,SAAiBC,EAAMC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GACnF,OAAOkC,EAAM5C,EAAMC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,EACjF,ICxBA,IASAoC,EAAAC,GAAAC,EATAC,EAAAD,MChDe,kDDyDf,gBAUAE,EATAC,EAAAL,GACAM,EAEAN,EE/BIO,EAAO,uBACPC,EAAO,sBACPC,EAAO,qBACPC,EAAO,uBA6BX,SAASC,EAAQvD,EAAGwD,EAAGC,EAASC,EAASC,EAAOC,EAAOC,EAAKC,EAAWC,GACtE,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,GAAKC,EAAOd,IAAWc,EAAOb,GAC7B,OAAOC,EASR,GAPe,IAAVD,IACJD,EAAQ,GAEM,IAAVA,IACJA,EAAQ,EACRC,EAAQ,GAEJ5D,GAAK,EAGT,OAFA6D,EAAKE,GAAcJ,EACnBE,EAAKE,EAAYD,GAAcF,EACxBC,EAmBR,IALAG,GAAS,EACTE,EAAO,EACPC,EAAO,EACPF,EAAO,EACPM,EAAKb,EACCc,EAAI,EAAGA,EAAIxE,EAAGwE,KACnBF,EAAKI,EAAKlB,EAAGe,KACHlB,GACTY,GAAQU,EAAML,EAAGnB,GACjBa,GAAS,GACEM,EAAKhB,EACXU,IACJE,GAAQS,EAAML,EAAGlB,IAGlBe,GAAQQ,EAAML,GAEfC,GAAMd,EA4BP,OAzBKG,EAAQ,KACZU,EAAKX,EAAQiB,EAAMhB,IACTP,EAGRY,GAFIN,EAAQ,GACZA,GAASR,IACSQ,EAAQC,GAGlBD,GAAUA,GAAUR,GAASA,EAAKS,KAEhCU,EAAKhB,EACXU,IAGHE,GAFIP,EAAQ,GACZA,GAASP,IACSO,EAAMC,GAGhBD,GAAUA,GAAUP,GAASA,EAAKQ,MAI5CO,GAAQR,GAAUA,EAAMC,IAIrBK,EAAO,IAENE,EAAO,GAAOM,EAAON,MACzBF,GAAUE,EAAKhB,EAASA,GAEzBU,EAAKE,GAAc,EAAMZ,EACzBU,EAAKE,EAAYD,GAAcG,EACxBJ,GAEHK,EAAO,GAENC,EAAO,GAAOM,EAAON,IACzBA,EAAOS,EAAMT,IACbD,EAAOU,EAAMV,GAASd,GACVe,GACXC,EAAOD,EACPE,EAAOH,IAEPE,EAAOF,EACPG,EAAOF,GAERR,EAAQ,EACRC,EAAQe,EAAMN,IAAW,EAAMM,EAAMP,EAAKC,MAE1CV,EAAQ,EAAMP,EACdQ,EAAQM,GAETL,EAAKE,GAAcJ,EACnBE,EAAKE,EAAYD,GAAcF,EACxBC,IAGRA,EAAKE,GAAc,EACnBF,EAAKE,EAAYD,GAAcK,EACxBN,EACR,CCrIA,SAASN,EAAQvD,EAAGwD,EAAGC,EAASE,EAAOC,GAMtC,OAAOlB,EAAM1C,EAAGwD,EAAGC,EAFdoB,EAAe7E,EAAGyD,GAESE,EAAOC,EADjC,IAAIkB,EAAc,GAC2B,EAAG,EACvD,CCzBAnC,EAAAY,EAAA,WCuBA,SAAiBvD,EAAGwD,EAAGC,EAASC,EAASC,EAAOC,EAAOC,EAAKC,EAAWC,GACtE,OAAOrB,EAAM1C,EAAGwD,EAAGC,EAASC,EAASC,EAAOC,EAAOC,EAAKC,EAAWC,EACpE,ICPA,IASInB,EAAMC,GAAYC,EATXC,EAAkBD,MC/Cd,kDDwDwB,gBAUvCiC,EATK9B,EAASL,GACJM,EAEAN,EE/BNoC,EAAa,GAgCjB,SAASC,EAAQjF,EAAGC,EAAGC,EAAUC,EAAUC,EAAS8E,EAAIC,EAAIC,EAAMC,EAAMC,EAAYC,GACnF,IAAIC,EACAC,EACA7C,EACA8C,EACAC,EACAC,EACAC,EACArB,EACAsB,EACAC,EACAC,EACAtE,EAWJ,GAPC8D,EADIJ,EAAO,EACHD,EAAKD,EAELA,EAAKC,EAEdK,GAAS,EAGJ3E,EAAY,CAAEX,EAAUC,IAAe,CAE3C,IADA0F,EAAKN,EACCf,EAAI,EAAGuB,EAAIb,EAAIV,EAAIgB,EAAOhB,IAAKuB,GAAKX,GACzCM,EAAML,EAAMQ,MACCE,GACZE,EAAOjG,EAAGC,EAAGE,EAAUC,EAAS2F,EAAE7F,EAAWD,EAAGE,EAAUC,EAASsF,EAAIxF,GAExE2F,GAAMP,EAEP,OAAOrF,CACP,CAGD,GAAa,KADbwF,EAAMS,EAAOlG,EAAEgF,GAAeA,GAE7B,IAAMc,EAAI,EAAGA,EAAIL,EAAKK,GAAKd,EAE1B,IADAa,EAAKN,EACCf,EAAI,EAAGuB,EAAIb,EAAIV,EAAIgB,EAAOhB,IAAKuB,GAAKX,EAAO,CAEhD,IADAM,EAAML,EAAMQ,MACCE,EAGZ,IAFAJ,EAAMvF,EAAY2F,EAAE7F,EACpB0F,EAAMxF,EAAYsF,EAAIxF,EAChB8F,EAAIF,EAAGE,EAAIF,EAAEd,EAAYgB,IAE9BpD,EAAM3C,EAAG0F,GADTjE,EAAIsE,EAAI7F,IAERF,EAAG0F,EAAIjE,GAAMzB,EAAG2F,EAAIlE,GACpBzB,EAAG2F,EAAIlE,GAAMkB,EAGfiD,GAAMP,CACN,CAGH,GAAKG,IAAQzF,EAEZ,IADA6F,EAAKN,EACCf,EAAI,EAAGuB,EAAIb,EAAIV,EAAIgB,EAAOhB,IAAKuB,GAAKX,EAAO,CAEhD,IADAM,EAAML,EAAMQ,MACCE,EAGZ,IAFAJ,EAAMvF,EAAY2F,EAAE7F,EACpB0F,EAAMxF,EAAYsF,EAAIxF,EAChB8F,EAAIP,EAAKO,EAAIhG,EAAGgG,IAErBpD,EAAM3C,EAAG0F,GADTjE,EAAIsE,EAAI7F,IAERF,EAAG0F,EAAIjE,GAAMzB,EAAG2F,EAAIlE,GACpBzB,EAAG2F,EAAIlE,GAAMkB,EAGfiD,GAAMP,CACN,CAEF,OAAOrF,CACR,CC/EA,SAASgF,EAAQlD,EAAO/B,EAAGC,EAAG+B,EAAKkD,EAAIC,EAAIE,EAAMc,GAChD,IAAIvD,EACAwD,EACAlE,EACAC,EACAkE,EACJ,IAAM/D,EAAUP,GACf,MAAM,IAAIQ,UAAWC,EAAQ,uEAAwET,IAEtG,GAAe,cAAVA,GAAyBC,EAAMsE,EAAK,EAAGtG,GAC3C,MAAM,IAAIyC,WAAYD,EAAQ,6FAA8FxC,EAAGgC,IAEhI,GAAKmE,EAAO,EACXC,EAAM,EACNC,EAAKnB,MACC,MAAKiB,EAAO,GAOlB,OAAOlG,EANPmG,GAAO,EACPC,EAAKnB,GAAQA,EAAGC,GAAMgB,EACtBvD,EAAMsC,EACNA,EAAKC,EACLA,EAAKvC,CAGL,CAQD,MAPe,iBAAVb,GACJG,EAAM,EACNC,EAAMH,IAENE,EAAMF,EACNG,EAAM,GAEAO,EAAM1C,EAAGC,EAAGiC,EAAKC,EAAK,EAAG+C,EAAIC,EAAIiB,EAAKf,EAAMc,EAAME,EAC1D,CC1DA1D,EAAAsC,EAAA,WCwBA,SAAiBjF,EAAGC,EAAGC,EAAUC,EAAUC,EAAS8E,EAAIC,EAAIC,EAAMC,EAAMC,EAAYC,GACnF,IAAI3C,EAYJ,OAXKwC,EAAO,GACXG,GAAcJ,EAAKG,EACnBA,IAAe,EACf1C,EAAMsC,EACNA,EAAKC,EACLA,EAAKvC,EACLwC,GAAQ,IAERG,GAAcL,EAAKI,EACnBF,EAAO,GAED1C,EAAM1C,EAAGC,EAAGC,EAAUC,EAAUC,EAAS8E,EAAIC,EAAIC,EAAMC,EAAMC,EAAYC,EACjF,IC5BA,IASI3C,EAAMC,GAAYC,EATXC,EAAkBD,MCvCd,kDDgDwB,gBAUvCyD,EATKtD,EAASL,GACJM,EAEAN,EEPV,SAAS4D,EAAQxG,EAAGyG,EAAGC,EAASC,EAASC,EAAGC,EAASC,GACpD,IAAIC,EACAC,EACAC,EACAzC,EAEJ,GAAW,IAANxE,EACJ,OAAO,EAMR,IAJAgH,EAAKF,EACLC,EAAKJ,EAGCnC,EAAI,EAAGA,EAAIxE,EAAE,EAAGwE,IAAM,CAE3B,GAAKiC,EAAGM,IAAQ,EACf,OAAOvC,EAAE,EAGVyC,EAAIL,EAAGI,GACPJ,EAAGI,GAAOC,EAAIR,EAAGM,GAGjBN,EADAM,GAAML,IACKE,EAAGI,GAAOC,EAErBD,GAAMH,CACN,CAED,OAAKJ,EAAGM,IAAQ,EACR/G,EAED,CACR,CC9BA,SAASwG,EAAQxG,EAAGyG,EAAGG,GACtB,GAAK5G,EAAI,EACR,MAAM,IAAIyC,WAAYD,EAAQ,+EAAgFxC,IAE/G,OAAO0C,EAAM1C,EAAGyG,EAAG,EAAG,EAAGG,EAAG,EAAG,EAChC,CCvBAjE,EAAA6D,EAAA,WCsBA,SAAiBxG,EAAGyG,EAAGC,EAASC,EAASC,EAAGC,EAASC,GACpD,GAAK9G,EAAI,EACR,MAAM,IAAIyC,WAAYD,EAAQ,+EAAgFxC,IAE/G,OAAO0C,EAAM1C,EAAGyG,EAAGC,EAASC,EAASC,EAAGC,EAASC,EAClD,ICNA,IASIlE,GAAMC,GAAYC,EATXC,EAAkBD,MClDd,kDD2DwB,gBAUvCoE,GATKjE,EAASL,IACJM,EAEAN,GE8XV,SAASuE,GAAQrH,EAAMC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GACnF,MAAc,UAATV,EAhMN,SAAoBC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAChF,IAAIC,EACAC,EACAC,EACAC,EAIJ,GAFAH,EAAKL,EACLM,EAAKF,EACAK,EAAY,CAAEX,EAAUC,IAAe,CAC3C,IAAMS,EAAK,EAAGA,EAAKb,EAAGa,IAAO,CAC5B,IAAMD,EAAKC,EAAID,EAAKX,EAAGW,IACtBN,EAAGK,EAAIC,EAAGJ,GAAcN,EAAGQ,EAAIE,EAAGR,GAEnCM,GAAMP,EACNQ,GAAMJ,CACN,CACD,OAAOD,CACP,CACD,IAAMO,EAAK,EAAGA,EAAKZ,EAAGY,IAAO,CAC5B,IAAMD,EAAK,EAAGA,GAAMG,EAAKF,EAAIb,EAAE,GAAKY,IACnCN,EAAGK,EAAIC,EAAGL,GAAcL,EAAGQ,EAAIE,EAAGT,GAEnCO,GAAMN,EACNO,GAAMH,CACN,CACD,OAAOF,CACR,CAuKSU,CAAWhB,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAElE,UAATV,EA/EN,SAAoBC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAChF,IAAIC,EACAC,EACAC,EACAC,EAIJ,GAFAH,EAAKL,EACLM,EAAKF,EACAK,EAAY,CAAEX,EAAUC,IAAe,CAC3C,IAAMS,EAAK,EAAGA,EAAKb,EAAGa,IAAO,CAC5B,IAAMD,EAAK,EAAGA,GAAMG,EAAKF,EAAIZ,EAAE,GAAKW,IACnCN,EAAGK,EAAIC,EAAGJ,GAAcN,EAAGQ,EAAIE,EAAGR,GAEnCM,GAAMP,EACNQ,GAAMJ,CACN,CACD,OAAOD,CACP,CACD,IAAMO,EAAK,EAAGA,EAAKZ,EAAGY,IAAO,CAC5B,IAAMD,EAAKC,EAAID,EAAKZ,EAAGY,IACtBN,EAAGK,EAAIC,EAAGL,GAAcL,EAAGQ,EAAIE,EAAGT,GAEnCO,GAAMN,EACNO,GAAMH,CACN,CACD,OAAOF,CACR,CAsDSW,CAAWjB,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GA3UjF,SAAkBT,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GAC9E,IAAIS,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAhB,EACAC,EACAC,EACAC,EACAc,EAqBJ,IAjBAL,GADAK,EAAIC,EAAW,CAAE5B,EAAGC,GAAK,CAAEE,EAAUC,GAAY,CAAEG,EAAUC,KACtDc,GACPG,EAAKE,EAAEE,GACPH,EAAKC,EAAEG,GAGPP,EAAKD,EAAI,GACTE,EAAKF,EAAI,GACTJ,EAAMO,EAAI,GACVN,EAAMM,EAAI,GAAQF,EAAGE,EAAG,GACxBL,EAAMM,EAAI,GACVL,EAAMK,EAAI,GAAQH,EAAGG,EAAG,GAGxBhB,EAAKL,EACLM,EAAKF,EAGCI,EAAK,EAAGA,EAAKW,EAAIX,IAAO,CAC7B,IAAMD,EAAK,EAAGA,EAAKW,EAAIX,IACtBN,EAAGK,GAAOT,EAAGQ,GACbA,GAAMQ,EACNP,GAAMS,EAEPV,GAAMS,EACNR,GAAMU,CACN,CACD,OAAOf,CACR,CAgSQyB,CAAS/B,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,EAC9E,CC7XA,SAAS2G,GAAQpF,EAAOjC,EAAMC,EAAGC,EAAGC,EAAG+B,EAAK3B,EAAG4B,GAC9C,IAAIC,EACAC,EACAC,EACAC,EACJ,IAAMC,EAAUP,GACf,MAAM,IAAIQ,UAAWC,EAAQ,uEAAwET,IAEtG,GAAe,iBAAVA,EACJG,EAAM,EACNC,EAAMH,EACNI,EAAM,EACNC,EAAMJ,MACA,CACN,GAAKD,EAAMhC,EACV,MAAM,IAAIyC,WAAYD,EAAQ,qFAAsFxC,EAAGgC,IAExH,GAAKC,EAAMjC,EACV,MAAM,IAAIyC,WAAYD,EAAQ,sFAAuFxC,EAAGiC,IAEzHC,EAAMF,EACNG,EAAM,EACNC,EAAMH,EACNI,EAAM,CACN,CACD,OAAOK,GAAM5C,EAAMC,EAAGC,EAAGC,EAAGiC,EAAKC,EAAK,EAAG9B,EAAG+B,EAAKC,EAAK,EACvD,CCrEAM,EAAAwE,GAAA,WCyCA,SAAiBrH,EAAMC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,GACnF,OAAOkC,GAAM5C,EAAMC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAAUC,EAAUC,EACjF,ICxBA,IASAoC,GAAAC,GAAAC,EATAC,EAAAD,MChDe,kDDyDf,gBAUAsE,GATAnE,EAAAL,IACAM,GAEAN,GEXA,SAASyE,GAAQrH,EAAGyG,EAAGC,EAASC,EAASC,EAAGC,EAASC,GACpD,IAAIC,EACAC,EACAC,EACAzC,EAEJ,GAAW,IAANxE,EACJ,OAAO,EAMR,IAJAgH,EAAKF,EACLC,EAAKJ,EAGCnC,EAAI,EAAGA,EAAIxE,EAAE,EAAGwE,IAAM,CAE3B,GAAKiC,EAAGM,IAAQ,EACf,OAAOvC,EAAE,EAGVyC,EAAIL,EAAGI,GACPJ,EAAGI,GAAOM,EAAKL,EAAIR,EAAGM,IAGtBN,EADAM,GAAML,GACIY,EAAKb,EAAGM,GAAOO,EAAKV,EAAGI,GAAOC,IAExCD,GAAMH,CACN,CAED,OAAKJ,EAAGM,IAAQ,EACR/G,EAED,CACR,CCnCA,SAASqH,GAAQrH,EAAGyG,EAAGG,GACtB,GAAK5G,EAAI,EACR,MAAM,IAAIyC,WAAYD,EAAQ,+EAAgFxC,IAE/G,OAAO0C,GAAM1C,EAAGyG,EAAG,EAAG,EAAGG,EAAG,EAAG,EAChC,CCvBAjE,EAAA0E,GAAA,WCsBA,SAAiBrH,EAAGyG,EAAGC,EAASC,EAASC,EAAGC,EAASC,GACpD,GAAK9G,EAAI,EACR,MAAM,IAAIyC,WAAYD,EAAQ,+EAAgFxC,IAE/G,OAAO0C,GAAM1C,EAAGyG,EAAGC,EAASC,EAASC,EAAGC,EAASC,EAClD,ICNA,IASIlE,GAAMC,GAAYC,EATXC,EAAkBD,MClDd,kDD2DwB,gBAUvCyE,GATKtE,EAASL,IACJM,GAEAN,GE3BV4E,GAAA,CAAA,EAUA7E,EAAA6E,GAAA,SAAA3H,GAUA8C,EAAA6E,GAAA,SAAAjE,GAUAZ,EAAA6E,GAAA,SAAAvC,GAUAtC,EAAA6E,GAAA,SAAAhB,IAUA7D,EAAA6E,GAAA,SAAAL,IAUAxE,EAAA6E,GAAA,SAAAH,IC5DA,IAAAG,GAAA,CAAA,EAUA7E,EAAA6E,GAAA,OAAA9E"}