{"version":3,"file":"index.mjs","sources":["../base/clacgv/lib/ndarray.js","../base/clacgv/lib/clacgv.js","../base/clacgv/lib/main.js","../base/clacpy/lib/base.js","../base/clacpy/lib/clacpy.js","../base/clacpy/lib/main.js","../base/clacpy/lib/ndarray.js","../base/clacpy/lib/index.js","../72d259953b7b64e405325d24038e8e","../base/claset/lib/base.js","../base/claset/lib/claset.js","../base/claset/lib/main.js","../base/claset/lib/ndarray.js","../base/claset/lib/index.js","../add2355bdc94b3dea27425e3abecbe","../base/claswp/lib/base.js","../base/claswp/lib/claswp.js","../base/claswp/lib/main.js","../base/claswp/lib/ndarray.js","../base/claswp/lib/index.js","../01d3563b4dab314243245006abf6f7","../base/crot/lib/ndarray.js","../base/crot/lib/crot.js","../base/crot/lib/main.js","../base/dge-trans/lib/base.js","../base/dge-trans/lib/dgetrans.js","../base/dge-trans/lib/main.js","../base/dge-trans/lib/ndarray.js","../base/dge-trans/lib/index.js","../d8e009fc0a16d3e571ca610021eac1","../base/dgttrf/lib/base.js","../base/dgttrf/lib/dgttrf.js","../base/dgttrf/lib/main.js","../base/dgttrf/lib/ndarray.js","../base/dgttrf/lib/index.js","../dc44dea6ad8f73dd6eee709bd25a28","../base/dlacpy/lib/base.js","../base/dlacpy/lib/dlacpy.js","../base/dlacpy/lib/main.js","../base/dlacpy/lib/ndarray.js","../cdf712c9ef0147952d9b233a2280a4","../base/dladiv/lib/base.js","../base/dladiv/lib/dladiv.js","../base/dladiv/lib/main.js","../base/dladiv/lib/ndarray.js","../base/dladiv/lib/index.js","../base/dlamch/lib/main.js","../base/iladlr/lib/base.js","../base/iladlr/lib/iladlr.js","../base/iladlr/lib/main.js","../base/iladlr/lib/ndarray.js","../base/iladlr/lib/index.js","../ea6ce5787a8d6f78c72dc366ba0eaa","../base/iladlc/lib/base.js","../base/iladlc/lib/iladlc.js","../base/iladlc/lib/main.js","../base/iladlc/lib/ndarray.js","../base/iladlc/lib/index.js","../5094ca905187443ad370822b3bd50c","../base/dlarf1f/lib/base.js","../base/dlarf1f/lib/dlarf1f.js","../base/dlarf1f/lib/main.js","../base/dlarf1f/lib/ndarray.js","../base/dlarf1f/lib/index.js","../360757b85d0700f2e4c5335cb6ebfa","../base/dlaset/lib/base.js","../base/dlaset/lib/dlaset.js","../base/dlaset/lib/main.js","../base/dlaset/lib/ndarray.js","../base/dlaset/lib/index.js","../4e4149109ca95ac099b79e0f9ac4ec","../base/dlassq/lib/base.js","../base/dlassq/lib/dlassq.js","../base/dlassq/lib/main.js","../base/dlassq/lib/ndarray.js","../base/dlassq/lib/index.js","../7f5b5bbaff0590da1b890f788fae5c","../base/dlaswp/lib/base.js","../base/dlaswp/lib/dlaswp.js","../base/dlaswp/lib/main.js","../base/dlaswp/lib/ndarray.js","../base/dlaswp/lib/index.js","../1a7bea76e04ff06a117d25245bfa0b","../base/dpttrf/lib/base.js","../base/dpttrf/lib/dpttrf.js","../base/dpttrf/lib/main.js","../base/dpttrf/lib/ndarray.js","../base/dpttrf/lib/index.js","../7cdb8a8d555d20ef239120831f8b6c","../base/sge-trans/lib/base.js","../base/sge-trans/lib/sgetrans.js","../base/sge-trans/lib/main.js","../base/sge-trans/lib/ndarray.js","../base/sge-trans/lib/index.js","../7fd8b6ec35a6c92225311ec88b33eb","../base/slacpy/lib/base.js","../base/slacpy/lib/slacpy.js","../base/slacpy/lib/main.js","../base/slacpy/lib/ndarray.js","../base/slacpy/lib/index.js","../4fada6c5812940eabdd59ed8336b2b","../base/slaswp/lib/base.js","../base/slaswp/lib/slaswp.js","../base/slaswp/lib/main.js","../base/slaswp/lib/ndarray.js","../base/slaswp/lib/index.js","../72a93ab894db000aa4d7c2b05d06c6","../base/spttrf/lib/base.js","../base/spttrf/lib/spttrf.js","../base/spttrf/lib/main.js","../base/spttrf/lib/ndarray.js","../base/spttrf/lib/index.js","../994c6a056f367bed1578a0e36695bd","../base/zlacgv/lib/ndarray.js","../base/zlacgv/lib/zlacgv.js","../base/zlacgv/lib/main.js","../base/zlacpy/lib/base.js","../base/zlacpy/lib/zlacpy.js","../base/zlacpy/lib/main.js","../base/zlacpy/lib/ndarray.js","../base/zlacpy/lib/index.js","../fbdb86e394eac3009bc52e6a60d349","../base/zlaset/lib/base.js","../base/zlaset/lib/zlaset.js","../base/zlaset/lib/main.js","../base/zlaset/lib/ndarray.js","../base/zlaset/lib/index.js","../5d6cf731aad5df392c282b9fe9f120","../base/zlaswp/lib/base.js","../base/zlaswp/lib/zlaswp.js","../base/zlaswp/lib/main.js","../base/zlaswp/lib/ndarray.js","../base/zlaswp/lib/index.js","../d3bf394ec9da992abebf91ca7a580c","../base/zrot/lib/ndarray.js","../base/zrot/lib/zrot.js","../base/zrot/lib/main.js","../base/lib/index.js","../base/dlapy2/lib/main.js","../base/dlapy3/lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a single-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - input array\n* @param {integer} strideCX - `cx` stride length\n* @param {NonNegativeInteger} offsetCX - starting `cx` index\n* @returns {Complex64Array} input array\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* clacgv( 3, cx, 1, 0 );\n*\n* var z = cx.get( 0 );\n* // returns <Complex64>[ 1.0, -2.0 ]\n*/\nfunction clacgv( N, cx, strideCX, offsetCX ) {\n\tvar cx32;\n\tvar ix;\n\tvar sx;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn cx;\n\t}\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tcx32 = reinterpret( cx, 0 );\n\n\t// Adjust the strides and offset:\n\tsx = strideCX * 2;\n\tix = ( offsetCX * 2 ) + 1; // index of the first imaginary component\n\n\t// Conjugate each element by negating the imaginary components...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tcx32[ ix ] = -cx32[ ix ];\n\t\tix += sx;\n\t}\n\treturn cx;\n}\n\n\n// EXPORTS //\n\nexport default clacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a single-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - input array\n* @param {integer} strideCX - `cx` stride length\n* @returns {Complex64Array} input array\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* clacgv( 3, cx, 1 );\n*\n* var z = cx.get( 0 );\n* // returns <Complex64>[ 1.0, -2.0 ]\n*/\nfunction clacgv( N, cx, strideCX ) {\n\treturn ndarray( N, cx, strideCX, stride2offset( N, strideCX ) );\n}\n\n\n// EXPORTS //\n\nexport default clacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport clacgv from './clacgv.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( clacgv, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default clacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 5.0, 6.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 5.0, 6.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 7.0, 8.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 1.0, 2.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyAll( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tB[ ib+1 ] = A[ ia+1 ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 7.0, 8.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 5.0, 6.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 5.0, 6.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 7.0, 8.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 3.0, 4.0, 0.0, 0.0, 1.0, 2.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia + ( i1*strideA2 );\n\t\t\tjb = ib + ( i1*strideB2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tjb = ib;\n\t\tja = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 0.0, 0.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float32Array>[ 5.0, 6.0, 0.0, 0.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float32Array( 8 );\n*\n* copyLower( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float32Array>[ 7.0, 8.0, 0.0, 0.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia;\n\t\t\tjb = ib;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tja = ia + ( i1*strideA1 );\n\t\tjb = ib + ( i1*strideB1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex64Array} `B`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex64>[ 5.0, 6.0 ]\n*\n* z = B.get( 3 );\n* // returns <Complex64>[ 7.0, 8.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Complex64Array>\n*\n* var z = B.get( 0 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* z = B.get( 3 );\n* // returns <Complex64>[ 7.0, 8.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex64>[ 5.0, 6.0 ]\n*\n* z = B.get( 3 );\n* // returns <Complex64>[ 7.0, 8.0 ]\n*/\nfunction clacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar viewA;\n\tvar viewB;\n\n\t// Reinterpret the input and output arrays as real-valued arrays of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\tviewB = reinterpret( B, 0 );\n\n\t// Adjust the strides and offsets accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\tstrideB1 *= 2;\n\tstrideB2 *= 2;\n\n\toffsetA *= 2;\n\toffsetB *= 2;\n\n\tif ( uplo === 'upper' ) {\n\t\tcopyUpper( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else if ( uplo === 'lower' ) {\n\t\tcopyLower( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else {\n\t\tcopyAll( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t}\n\treturn B;\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Complex64Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex64Array} `B`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*/\nfunction clacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport clacpy from './clacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( clacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex64Array} `B`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = B.get( 4 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*/\nfunction clacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/clacpy\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import clacpy from '@stdlib/lapack/base/clacpy';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex64Array( 4 );\n*\n* clacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import clacpy from '@stdlib/lapack/base/clacpy';\n*\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex64Array( 12 );\n*\n* clacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar clacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tclacpy = main;\n} else {\n\tclacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default clacpy;\n\n// exports: { \"ndarray\": \"clacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/clacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\nimport loopOrder from '@stdlib/ndarray/base/nullary-loop-interchange-order';\nimport realf from '@stdlib/complex/float32/real';\nimport imagf from '@stdlib/complex/float32/imag';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Sets the diagonal of a single-precision complex floating-point matrix `A` to a specified value.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 3, 1.0, 2.0, A, 6, 2, 0 );\n* // A => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 3, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, 0.0, 0.0 ]\n*/\nfunction setDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA ) {\n\tvar sa;\n\tvar ia;\n\tvar i;\n\n\tsa = strideA1 + strideA2;\n\tia = offsetA;\n\tfor ( i = 0; i < min( M, N ); i++ ) {\n\t\tA[ ia ] = breal;\n\t\tA[ ia+1 ] = bimag;\n\t\tia += sa;\n\t}\n\treturn A;\n}\n\n/**\n* Sets all elements of a single-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setAll( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar da0;\n\tvar da1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\n\t// Set the pointer to the first indexed element:\n\tia = offsetA;\n\n\t// Fill the array with a scalar value...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tA[ ia ] = areal;\n\t\t\tA[ ia+1 ] = aimag;\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t}\n\t// Replace the diagonal:\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\n\treturn A;\n}\n\n/**\n* Sets the upper triangular/trapezoidal part of a single-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*/\nfunction setUpper( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n* Sets the lower triangular/trapezoidal part of a single-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float32Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float32Array} `A`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float32Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float32Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( 8 );\n* // returns <Float32Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float32Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setLower( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia + ( i1*strideA1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n\n// MAIN //\n\n/**\n* Sets elements of matrix `A` to specified values.\n*\n* @private\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64} alpha - value assigned to off-diagonal elements\n* @param {Complex64} beta - value assigned to diagonal elements\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex64Array} `A`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'all', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'upper', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'lower', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*/\nfunction claset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar viewA;\n\tvar ar;\n\tvar ai;\n\tvar br;\n\tvar bi;\n\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\n\t// Adjust the strides and offset accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\n\toffsetA *= 2;\n\n\t// Decompose the scalars to real and imaginary components:\n\tar = realf( alpha );\n\tai = imagf( alpha );\n\tbr = realf( beta );\n\tbi = imagf( beta );\n\n\tif ( uplo === 'upper' ) {\n\t\tsetUpper( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else if ( uplo === 'lower' ) {\n\t\tsetLower( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else {\n\t\tsetAll( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a single-precision complex floating-point matrix to specified values.\n*\n* @param {string} order - storage layout of `A`\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64} alpha - value assigned to off-diagonal elements\n* @param {Complex64} beta - value assigned to diagonal elements\n* @param {Complex64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex64Array} `A`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'upper', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 4 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'lower', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*/\nfunction claset( order, uplo, M, N, alpha, beta, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( uplo, M, N, alpha, beta, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport claset from './claset.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( claset, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a single-precision complex floating-point matrix to specified values.\n*\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex64} alpha - value assigned to off-diagonal elements\n* @param {Complex64} beta - value assigned to diagonal elements\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex64Array} `A`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 5 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = A.get( 3 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 5 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'upper', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*\n* z = A.get( 3 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var A = new Complex64Array( 5 );\n*\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'lower', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex64>[ 0.0, 0.0 ]\n*\n* z = A.get( 3 );\n* // returns <Complex64>[ 1.0, 2.0 ]\n*/\nfunction claset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\treturn base( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default claset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to set the off-diagonal elements and the diagonal elements of a single-precision complex floating-point matrix to specified values.\n*\n* @module @stdlib/lapack/base/claset\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import claset from '@stdlib/lapack/base/claset';\n*\n* var A = new Complex64Array( 4 );\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n* import claset from '@stdlib/lapack/base/claset';\n*\n* var A = new Complex64Array( 5 );\n* var alpha = new Complex64( 1.0, 2.0 );\n* var beta = new Complex64( 3.0, 4.0 );\n*\n* claset.ndarray( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex64>[ 3.0, 4.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar claset;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tclaset = main;\n} else {\n\tclaset = tmp;\n}\n\n\n// EXPORTS //\n\nexport default claset;\n\n// exports: { \"ndarray\": \"claset.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/claset/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\nimport floor from '@stdlib/math/base/special/floor';\nimport { ndarray as cswap } from '@stdlib/blas/base/cswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* claswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex64Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction claswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar viewA;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `cswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tcswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\tviewA = reinterpret( A, 0 );\n\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\toffsetA *= 2;\n\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default claswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Complex64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* claswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex64Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction claswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default claswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport claswp from './claswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( claswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default claswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex64Array from '@stdlib/array/complex64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* claswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex64Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction claswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default claswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack/base/claswp\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex64Array from '@stdlib/array/complex64';\n* import claswp from '@stdlib/lapack/base/claswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* claswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex64Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex64Array from '@stdlib/array/complex64';\n* import claswp from '@stdlib/lapack/base/claswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* claswp.ndarray( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex64Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar claswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tclaswp = main;\n} else {\n\tclaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default claswp;\n\n// exports: { \"ndarray\": \"claswp.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/claswp/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport f32 from '@stdlib/number/float64/base/to-float32';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex64';\nimport realf from '@stdlib/complex/float32/real';\nimport imagf from '@stdlib/complex/float32/imag';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - first input array\n* @param {integer} strideCX - `cx` stride length\n* @param {NonNegativeInteger} offsetCX - starting `cx` index\n* @param {Complex64Array} cy - second input array\n* @param {integer} strideCY - `cy` stride length\n* @param {NonNegativeInteger} offsetCY - starting `cy` index\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex64} s - sine of the angle of rotation\n* @returns {Complex64Array} `cy`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var cy = new Complex64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex64( 0.3, 0.4 );\n*\n* crot( cx.length, cx, 1, 0, cy, 1, 0, 0.8, s );\n*\n* var z = cy.get( 0 );\n* // returns <Complex64>[ ~-1.1, ~-0.2 ]\n*\n* z = cx.get( 0 );\n* // returns <Complex64>[ ~0.8, ~1.6 ]\n*/\nfunction crot( N, cx, strideCX, offsetCX, cy, strideCY, offsetCY, c, s ) {\n\tvar viewX;\n\tvar viewY;\n\tvar sr;\n\tvar si;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar yr;\n\tvar yi;\n\tvar xr;\n\tvar xi;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn cy;\n\t}\n\tviewX = reinterpret( cx, 0 );\n\tviewY = reinterpret( cy, 0 );\n\n\tix = offsetCX * 2;\n\tiy = offsetCY * 2;\n\n\tsx = strideCX * 2;\n\tsy = strideCY * 2;\n\n\tsr = realf( s );\n\tsi = imagf( s );\n\n\tfor ( i = 0; i < N; i++ ) {\n\t\tyr = viewY[ iy ];\n\t\tyi = viewY[ iy+1 ];\n\t\txr = viewX[ ix ];\n\t\txi = viewX[ ix+1 ];\n\n\t\t// Compute tmp = c * cx[ ix ] + s * cy[ iy ]\n\t\tviewX[ ix ] = f32( f32( c*xr ) + f32( f32( sr*yr ) - f32( si*yi ) ) );\n\t\tviewX[ ix+1 ] = f32( f32( c*xi ) + f32( f32( sr*yi ) + f32( si*yr ) ) );\n\n\t\t// Compute cy[ iy ] = c * cy[ iy ] - conj(s) * cx[ ix ]\n\t\tviewY[ iy ] = f32( f32( c*yr ) - f32( f32( sr*xr ) + f32( si*xi ) ) );\n\t\tviewY[ iy+1 ] = f32( f32( c*yi ) - f32( f32( sr*xi ) - f32( si*xr ) ) );\n\n\t\tix += sx;\n\t\tiy += sy;\n\t}\n\treturn cy;\n}\n\n\n// EXPORTS //\n\nexport default crot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex64Array} cx - first input array\n* @param {integer} strideCX - `cx` stride length\n* @param {Complex64Array} cy - second input array\n* @param {integer} strideCY - `cy` stride length\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex64} s - sine of the angle of rotation\n* @returns {Complex64Array} `cy`\n*\n* @example\n* import Complex64Array from '@stdlib/array/complex64';\n* import Complex64 from '@stdlib/complex/float32/ctor';\n*\n* var cx = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var cy = new Complex64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex64( 0.3, 0.4 );\n*\n* crot( cx.length, cx, 1, cy, 1, 0.8, s );\n*\n* var z = cy.get( 0 );\n* // returns <Complex64>[ ~-1.1, ~-0.2 ]\n*\n* z = cx.get( 0 );\n* // returns <Complex64>[ ~0.8, ~1.6 ]\n*/\nfunction crot( N, cx, strideCX, cy, strideCY, c, s ) {\n\tvar ix = stride2offset( N, strideCX );\n\tvar iy = stride2offset( N, strideCY );\n\treturn ndarray( N, cx, strideCX, ix, cy, strideCY, iy, c, s );\n}\n\n\n// EXPORTS //\n\nexport default crot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport crot from './crot.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( crot, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default crot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float64Array} `out`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction dgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\tvar isrm;\n\tvar da0;\n\tvar da1;\n\tvar do0;\n\tvar do1;\n\tvar ia;\n\tvar io;\n\tvar i0;\n\tvar i1;\n\tvar S0;\n\tvar S1;\n\n\t// Note on variable naming convention: S#, da#, do#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Perform loop interchange based on the layout format of the output matrix...\n\tisrm = isRowMajor( [ strideO1, strideO2 ] );\n\tif ( isrm ) {\n\t\t// For row-major matrices, the last dimensions have the fastest changing indices...\n\t\tS0 = M;\n\t\tS1 = N;\n\t\tda0 = strideA1;                   // offset increment for innermost loop\n\t\tda1 = strideA2 - ( S0*strideA1 ); // offset increment for outermost loop\n\t\tdo0 = strideO2;\n\t\tdo1 = strideO1 - ( S0*strideO2 );\n\t} else {\n\t\t// For column-major matrices, the first dimensions have the fastest changing indices...\n\t\tS0 = N;\n\t\tS1 = M;\n\t\tda0 = strideA2;                   // offset increment for innermost loop\n\t\tda1 = strideA1 - ( S0*strideA2 ); // offset increment for outermost loop\n\t\tdo0 = strideO1;\n\t\tdo1 = strideO2 - ( S0*strideO1 );\n\t}\n\tia = offsetA;\n\tio = offsetO;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tout[ io ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tio += do0;\n\t\t}\n\t\tia += da1;\n\t\tio += do1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @param {string} order - storage layout\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} out - output matrix\n* @param {PositiveInteger} LDO - stride of the first dimension of `out` (a.k.a., leading dimension of the matrix `out`)\n* @throws {TypeError} first argument must be a valid order\n* @returns {Float64Array} `out`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction dgetrans( order, M, N, A, LDA, out, LDO ) {\n\tvar sa1;\n\tvar sa2;\n\tvar so1;\n\tvar so2;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tso1 = 1;\n\t\tso2 = LDO;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tso1 = LDO;\n\t\tso2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0, out, so1, so2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dgetrans from './dgetrans.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dgetrans, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float64Array} `out`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction dgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\treturn base( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO );\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to convert a matrix from row-major layout to column-major layout or vice versa.\n*\n* @module @stdlib/lapack/base/dge-trans\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dgetrans from '@stdlib/lapack/base/dge-trans';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dgetrans from '@stdlib/lapack/base/dge-trans';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float64Array( 6 );\n*\n* out = dgetrans.ndarray( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float64Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dgetrans;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdgetrans = main;\n} else {\n\tdgetrans = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dgetrans;\n\n// exports: { \"ndarray\": \"dgetrans.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dge-trans/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport abs from '@stdlib/math/base/special/abs';\n\n\n// MAIN //\n\n/**\n* Computes an `LU` factorization of a real tridiagonal matrix `A` using elimination with partial pivoting and row interchanges.\n*\n* ## Notes\n*\n* -   `DL` should have `N-1` indexed elements and is overwritten by the multipliers that define the matrix `L` from the `LU` factorization of `A`.\n* -   `D` should have `N` indexed elements and is overwritten by the diagonal elements of the upper triangular matrix `U` from the `LU` factorization of `A`.\n* -   `DU` should have `N-1` indexed elements and is overwritten by the elements of the first super-diagonal of `U`.\n* -   `DU2` should have `N-2` indexed elements and is overwritten by the elements of the second super-diagonal of `U`.\n* -   For `0 <= i < n`, row `i` of the matrix is interchanged with row `IPIV(i)`. `IPIV(i)` will always be either `i` or `i+1`. `IPIV(i) = i` indicates a row interchange was not required.\n*\n* @private\n* @param {NonNegativeInteger} N - number of rows/columns in `A`\n* @param {Float64Array} DL - the first sub diagonal of `A`\n* @param {integer} strideDL - stride length for `DL`\n* @param {NonNegativeInteger} offsetDL - starting index of `DL`\n* @param {Float64Array} D - the diagonal of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} DU - the first super-diagonal of `A`\n* @param {integer} strideDU - stride length for `DU`\n* @param {NonNegativeInteger} offsetDU - starting index of `DU`\n* @param {Float64Array} DU2 - the second super-diagonal of `U`\n* @param {integer} strideDU2 - stride length for `DU2`\n* @param {NonNegativeInteger} offsetDU2 - starting index of `DU2`\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - stride length for `IPIV`\n* @param {NonNegativeInteger} offsetIPIV - starting index of `IPIV`\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* var Int32Array = require( '@stdlib/array/int32' )\n*\n* var DL = new Float64Array( [ 1.0, 1.0 ] );\n* var D = new Float64Array( [ 2.0, 3.0, 1.0 ] );\n* var DU = new Float64Array( [ 1.0, 1.0 ] );\n* var DU2 = new Float64Array( [ 0.0 ] );\n* var IPIV = new Int32Array( [ 0, 0, 0 ] );\n*\n* dgttrf( 3, DL, 1, 0, D, 1, 0, DU, 1, 0, DU2, 1, 0, IPIV, 1, 0 );\n* // DL => <Float64Array>[ 0.5, 0.4 ]\n* // D => <Float64Array>[ 2.0, 2.5, 0.6 ]\n* // DU => <Float64Array>[ 1.0, 1.0 ]\n* // DU2 => <Float64Array>[ 0.0 ]\n* // IPIV => <Int32Array>[ 0, 1, 2 ]\n*/\nfunction dgttrf( N, DL, strideDL, offsetDL, D, strideD, offsetD, DU, strideDU, offsetDU, DU2, strideDU2, offsetDU2, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line stdlib/jsdoc-doctest-decimal-point, max-len, max-params\n\tvar fact;\n\tvar temp;\n\tvar idu2;\n\tvar idu;\n\tvar idl;\n\tvar id;\n\tvar ip;\n\tvar i;\n\tvar j;\n\n\tif ( N === 0 ) {\n\t\treturn 0;\n\t}\n\tidu2 = offsetDU2;\n\tip = offsetIPIV;\n\n\t// Initialize values in IPIV and DU2...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tIPIV[ ip ] = i;\n\t\tif ( i < N-2 ) {\n\t\t\tDU2[ idu2 ] = 0;\n\t\t}\n\t\tip += strideIPIV;\n\t\tidu2 += strideDU2;\n\t}\n\t// Initialize pointers to the first indexed elements:\n\tidu2 = offsetDU2;\n\tip = offsetIPIV;\n\tidl = offsetDL;\n\tid = offsetD;\n\tidu = offsetDU;\n\n\tfor ( i = 0; i < N-2; i++ ) {\n\t\t// Check whether row interchange is required, and, if not, eliminate the i-th element of DL...\n\t\tif ( abs( D[ id ] ) >= abs( DL[ idl ] ) ) {\n\t\t\tif ( D[ id ] !== 0.0 ) {\n\t\t\t\tfact = DL[ idl ] / D[ id ];\n\t\t\t\tDL[ idl ] = fact;\n\t\t\t\tD[ id+strideD ] = D[ id+strideD ] - ( fact*DU[ idu ] );\n\t\t\t}\n\t\t}\n\t\t// Otherwise, interchange the ith and (i+1)th rows and eliminate i-th element of DL...\n\t\telse {\n\t\t\tfact = D[ id ] / DL[ idl ];\n\t\t\tD[ id ] = DL[ idl ];\n\t\t\tDL[ idl ] = fact;\n\t\t\ttemp = DU[ idu ];\n\n\t\t\tj = id + strideD;\n\t\t\tDU[ idu ] = D[ j ];\n\t\t\tD[ j ] = temp - ( fact*D[ j ] );\n\n\t\t\tj = idu + strideDU;\n\t\t\tDU2[ idu2 ] = DU[ j ];\n\t\t\tDU[ j ] *= -fact;\n\n\t\t\tIPIV[ ip ] = i + 1;\n\t\t}\n\t\tid += strideD;\n\t\tidl += strideDL;\n\t\tidu += strideDU;\n\t\tidu2 += strideDU2;\n\t\tip += strideIPIV;\n\t}\n\t// Perform the final (N-2)th iteration separately for the last two rows...\n\tif ( N > 1 ) {\n\t\ti = N - 2;\n\t\tif ( abs( D[ id ] ) >= abs( DL[ idl ] ) ) {\n\t\t\tif ( D[ id ] !== 0 ) {\n\t\t\t\tfact = DL[ idl ] / D[ id ];\n\t\t\t\tDL[ idl ] = fact;\n\t\t\t\tD[ id+strideD ] = D[ id+strideD ] - ( fact*DU[ idu ] );\n\t\t\t}\n\t\t} else {\n\t\t\tfact = D[ id ] / DL[ idl ];\n\t\t\tD[ id ] = DL[ idl ];\n\t\t\tDL[ idl ] = fact;\n\t\t\ttemp = DU[ idu ];\n\n\t\t\tj = id + strideD;\n\t\t\tDU[ idu ] = D[ j ];\n\t\t\tD[ j ] = temp - ( fact*D[ j ] );\n\n\t\t\tIPIV[ ip ] = i + 1;\n\t\t}\n\t}\n\tid = offsetD;\n\n\t// Check whether U is singular...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( D[ id ] === 0.0 ) {\n\t\t\treturn i;\n\t\t}\n\t\tid += strideD;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default dgttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes an `LU` factorization of a real tridiagonal matrix `A` using elimination with partial pivoting and row interchanges.\n*\n* ## Notes\n*\n* -   `DL` should have `N-1` elements and is overwritten by the multipliers that define the matrix `L` from the `LU` factorization of `A`.\n* -   `D` is overwritten by the diagonal elements of the upper triangular matrix `U` from the `LU` factorization of `A`.\n* -   `DU` should have `N-1` elements and is overwritten by the elements of the first super-diagonal of `U`.\n* -   `DU2` should have `N-2` elements and is overwritten by the elements of the second super-diagonal of `U`.\n* -   For `0 <= i < n`, row `i` of the matrix is interchanged with row `IPIV(i)`. `IPIV(i)` will always be either `i` or `i+1`. `IPIV(i) = i` indicates a row interchange was not required.\n*\n* @param {NonNegativeInteger} N - number of rows/columns in `A`\n* @param {Float64Array} DL - the first sub diagonal of `A`\n* @param {Float64Array} D - the diagonal of `A`, expects N indexed elements\n* @param {Float64Array} DU - the first super-diagonal of `A`\n* @param {Float64Array} DU2 - the second super-diagonal of `U`\n* @param {Int32Array} IPIV - vector of pivot indices\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import Int32Array from '@stdlib/array/int32';\n*\n* var DL = new Float64Array( [ 1.0, 1.0 ] );\n* var D = new Float64Array( [ 2.0, 3.0, 1.0 ] );\n* var DU = new Float64Array( [ 1.0, 1.0 ] );\n* var DU2 = new Float64Array( [ 0.0 ] );\n* var IPIV = new Int32Array( [ 0, 0, 0 ] );\n*\n* dgttrf( 3, DL, D, DU, DU2, IPIV );\n* // DL => <Float64Array>[ 0.5, 0.4 ]\n* // D => <Float64Array>[ 2.0, 2.5, 0.6 ]\n* // DU => <Float64Array>[ 1.0, 1.0 ]\n* // DU2 => <Float64Array>[ 0.0 ]\n* // IPIV => <Int32Array>[ 0, 1, 2 ]\n*/\nfunction dgttrf( N, DL, D, DU, DU2, IPIV ) { // eslint-disable-line stdlib/jsdoc-doctest-decimal-point\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, DL, 1, 0, D, 1, 0, DU, 1, 0, DU2, 1, 0, IPIV, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dgttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dgttrf from './dgttrf.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dgttrf, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dgttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes an `LU` factorization of a real tridiagonal matrix `A` using elimination with partial pivoting and row interchanges and alternative indexing semantics.\n*\n* ## Notes\n*\n* -   `DL` should have `N-1` indexed elements and is overwritten by the multipliers that define the matrix `L` from the `LU` factorization of `A`.\n* -   `D` should have `N` indexed elements and is overwritten by the diagonal elements of the upper triangular matrix `U` from the `LU` factorization of `A`.\n* -   `DU` should have `N-1` indexed elements and is overwritten by the elements of the first super-diagonal of `U`.\n* -   `DU2` should have `N-2` indexed elements and is overwritten by the elements of the second super-diagonal of `U`.\n* -   For `0 <= i < n`, row `i` of the matrix is interchanged with row `IPIV(i)`. `IPIV(i)` will always be either `i` or `i+1`. `IPIV(i) = i` indicates a row interchange was not required.\n*\n* @param {NonNegativeInteger} N - number of rows/columns in `A`\n* @param {Float64Array} DL - the first sub diagonal of `A`\n* @param {integer} strideDL - stride length for `DL`\n* @param {NonNegativeInteger} offsetDL - starting index of `DL`\n* @param {Float64Array} D - the diagonal of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} DU - the first super-diagonal of `A`\n* @param {integer} strideDU - stride length for `DU`\n* @param {NonNegativeInteger} offsetDU - starting index of `DU`\n* @param {Float64Array} DU2 - the second super-diagonal of `U`\n* @param {integer} strideDU2 - stride length for `DU2`\n* @param {NonNegativeInteger} offsetDU2 - starting index of `DU2`\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - stride length for `IPIV`\n* @param {NonNegativeInteger} offsetIPIV - starting index of `IPIV`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var DL = new Float64Array( [ 1.0, 1.0 ] );\n* var D = new Float64Array( [ 2.0, 3.0, 1.0 ] );\n* var DU = new Float64Array( [ 1.0, 1.0 ] );\n* var DU2 = new Float64Array( [ 0.0 ] );\n* var IPIV = new Int32Array( [ 0, 0, 0 ] );\n*\n* dgttrf( 3, DL, 1, 0, D, 1, 0, DU, 1, 0, DU2, 1, 0, IPIV, 1, 0 );\n* // DL => <Float64Array>[ 0.5, 0.4 ]\n* // D => <Float64Array>[ 2.0, 2.5, 0.6 ]\n* // DU => <Float64Array>[ 1.0, 1.0 ]\n* // DU2 => <Float64Array>[ 0.0 ]\n* // IPIV => <Int32Array>[ 0, 1, 2 ]\n*/\nfunction dgttrf( N, DL, strideDL, offsetDL, D, strideD, offsetD, DU, strideDU, offsetDU, DU2, strideDU2, offsetDU2, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line stdlib/jsdoc-doctest-decimal-point, max-len, max-params\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, DL, strideDL, offsetDL, D, strideD, offsetD, DU, strideDU, offsetDU, DU2, strideDU2, offsetDU2, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default dgttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to compute an `LU` factorization of a real tridiagonal matrix `A` using elimination with partial pivoting and row interchanges.\n*\n* @module @stdlib/lapack/base/dgttrf\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import Int32Array from '@stdlib/array/int32';\n* import dgttrf from '@stdlib/lapack/base/dgttrf';\n*\n* var DL = new Float64Array( [ 1.0, 1.0 ] );\n* var D = new Float64Array( [ 2.0, 3.0, 1.0 ] );\n* var DU = new Float64Array( [ 1.0, 1.0 ] );\n* var DU2 = new Float64Array( [ 0.0 ] );\n* var IPIV = new Int32Array( [ 0, 0, 0 ] );\n*\n* dgttrf( 3, DL, D, DU, DU2, IPIV );\n* // DL => <Float64Array>[ 0.5, 0.4 ]\n* // D => <Float64Array>[ 2.0, 2.5, 0.6 ]\n* // DU => <Float64Array>[ 1.0, 1.0 ]\n* // DU2 => <Float64Array>[ 0.0 ]\n* // IPIV => <Int32Array>[ 0, 1, 2 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import Int32Array from '@stdlib/array/int32';\n* import dgttrf from '@stdlib/lapack/base/dgttrf';\n*\n* var DL = new Float64Array( [ 1.0, 1.0 ] );\n* var D = new Float64Array( [ 2.0, 3.0, 1.0 ] );\n* var DU = new Float64Array( [ 1.0, 1.0 ] );\n* var DU2 = new Float64Array( [ 0.0 ] );\n* var IPIV = new Int32Array( [ 0, 0, 0 ] );\n*\n* dgttrf.ndarray( 3, DL, 1, 0, D, 1, 0, DU, 1, 0, DU2, 1, 0, IPIV, 1, 0 );\n* // DL => <Float64Array>[ 0.5, 0.4 ]\n* // D => <Float64Array>[ 2.0, 2.5, 0.6 ]\n* // DU => <Float64Array>[ 1.0, 1.0 ]\n* // DU2 => <Float64Array>[ 0.0 ]\n* // IPIV => <Int32Array>[ 0, 1, 2 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dgttrf;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdgttrf = main;\n} else {\n\tdgttrf = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dgttrf;\n\n// exports: { \"ndarray\": \"dgttrf.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dgttrf/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 1.0, 4.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 3.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 3.0, 2.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 4.0, 1.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 1.0, 4.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyAll( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 2.0, 3.0, 1.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 1.0, 0.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 0.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 3.0, 0.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 3.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 4.0, 0.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 2.0, 0.0, 1.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 0.0, 4.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 0.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 2.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float64Array>[ 2.0, 0.0, 1.0, 3.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float64Array>[ 3.0, 0.0, 4.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* copyLower( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float64Array>[ 4.0, 0.0, 3.0, 1.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction dlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( uplo === 'upper' ) {\n\t\treturn copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\tif ( uplo === 'lower' ) {\n\t\treturn copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\treturn copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( 4 );\n*\n* dlacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n* // B => <Float64Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction dlacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlacpy from './dlacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 3.0, 0.0, 5.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float64Array( 6 );\n*\n* dlacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float64Array>[ 0.0, 0.0, 2.0, 0.0, 4.0, 5.0 ]\n*/\nfunction dlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default dlacpy;\n","export default '/home/runner/work/lapack/lapack/base/dladiv/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { assign as cdiv } from '@stdlib/complex/float64/base/div';\nimport Float64Array from '@stdlib/array/float64';\n\n\n// VARIABLES //\n\nvar out = new Float64Array( 2 );\n\n\n// MAIN //\n\n/**\n* Divides two double-precision complex floating-point numbers in real arithmetic.\n*\n* @private\n* @param {number} a - real component of numerator\n* @param {number} b - imaginary component of numerator\n* @param {number} c - real component of denominator\n* @param {number} d - imaginary component of denominator\n* @param {Float64Array} P - array containing an element which is overwritten by the real part of the quotient\n* @param {NonNegativeInteger} offsetP - index of the element in `P`\n* @param {Float64Array} Q - array containing an element which is overwritten by the imaginary part of the quotient\n* @param {NonNegativeInteger} offsetQ - index of the element in `Q`\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var P = new Float64Array( 1 );\n* var Q = new Float64Array( 1 );\n*\n* dladiv( -13.0, -1.0, -2.0, 1.0, P, 0, Q, 0 );\n* // P => <Float64Array>[ 5.0 ]\n* // Q => <Float64Array>[ 3.0 ]\n*/\nfunction dladiv( a, b, c, d, P, offsetP, Q, offsetQ ) {\n\tcdiv( a, b, c, d, out, 1, 0 );\n\tP[ offsetP ] = out[ 0 ];\n\tQ[ offsetQ ] = out[ 1 ];\n}\n\n\n// EXPORTS //\n\nexport default dladiv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Divides two double-precision complex floating-point numbers in real arithmetic.\n*\n* @param {number} a - real component of numerator\n* @param {number} b - imaginary component of numerator\n* @param {number} c - real component of denominator\n* @param {number} d - imaginary component of denominator\n* @param {Float64Array} P - array containing a single element which is overwritten by the real part of the quotient\n* @param {Float64Array} Q - array containing a single element which is overwritten by the imaginary part of the quotient\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var P = new Float64Array( 1 );\n* var Q = new Float64Array( 1 );\n*\n* dladiv( -13.0, -1.0, -2.0, 1.0, P, Q );\n* // P => <Float64Array>[ 5.0 ]\n* // Q => <Float64Array>[ 3.0 ]\n*/\nfunction dladiv( a, b, c, d, P, Q ) {\n\treturn base( a, b, c, d, P, 0, Q, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dladiv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dladiv from './dladiv.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dladiv, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dladiv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Divides two double-precision complex floating-point numbers in real arithmetic.\n*\n* @param {number} a - real component of numerator\n* @param {number} b - imaginary component of numerator\n* @param {number} c - real component of denominator\n* @param {number} d - imaginary component of denominator\n* @param {Float64Array} P - array containing an element which is overwritten by the real part of the quotient\n* @param {NonNegativeInteger} offsetP - index of the element in `P`\n* @param {Float64Array} Q - array containing an element which is overwritten by the imaginary part of the quotient\n* @param {NonNegativeInteger} offsetQ - index of the element in `Q`\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var P = new Float64Array( 1 );\n* var Q = new Float64Array( 1 );\n*\n* dladiv( -13.0, -1.0, -2.0, 1.0, P, 0, Q, 0 );\n* // P => <Float64Array>[ 5.0 ]\n* // Q => <Float64Array>[ 3.0 ]\n*/\nfunction dladiv( a, b, c, d, P, offsetP, Q, offsetQ ) {\n\treturn base( a, b, c, d, P, offsetP, Q, offsetQ );\n}\n\n\n// EXPORTS //\n\nexport default dladiv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to divide two double-precision complex floating-point numbers.\n*\n* @module @stdlib/lapack/base/dladiv\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dladiv from '@stdlib/lapack/base/dladiv';\n*\n* var P = new Float64Array( 1 );\n* var Q = new Float64Array( 1 );\n*\n* dladiv( -13.0, -1.0, -2.0, 1.0, P, Q );\n* // P => <Float64Array>[ 5.0 ]\n* // Q => <Float64Array>[ 3.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dladiv;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdladiv = main;\n} else {\n\tdladiv = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dladiv;\n\n// exports: { \"ndarray\": \"dladiv.ndarray\" }\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport FLOAT64_EPS from '@stdlib/constants/float64/eps';\nimport FLOAT64_SMALLEST_NORMAL from '@stdlib/constants/float64/smallest-normal';\nimport FLOAT64_MIN_EXPONENT from '@stdlib/constants/float64/min-base2-exponent';\nimport FLOAT64_MAX_EXPONENT from '@stdlib/constants/float64/max-base2-exponent';\nimport FLOAT64_MAX from '@stdlib/constants/float64/max';\nimport FLOAT64_PRECISION from '@stdlib/constants/float64/precision';\nimport lowercase from '@stdlib/string/base/lowercase';\n\n\n// VARIABLES //\n\nvar RADIX = 2.0;\n\n\n// MAIN //\n\n/**\n* Determines double-precision floating-point machine parameters.\n*\n* ## Notes\n*\n* -   The `cmach` parameter is a string which specifies the double-precision machine parameter to be returned. The function recognizes the following characters:\n*\n*     -   `'E'`/`'e'`: (eps) relative machine precision.\n*     -   `'S'`/`'s'`: (sfmin) safe minimum such that `1/sfmin` does not overflow.\n*     -   `'B'`/`'b'`: (base) base of the machine (also known as the floating-point radix).\n*     -   `'P'`/`'p'`: (prec) `eps*base`.\n*     -   `'N'`/`'n'`: (t) number of (base) digits in the mantissa.\n*     -   `'R'`/`'r'`: (rnd) `1.0` when rounding occurs in addition and `0.0` otherwise.\n*     -   `'M'`/`'m'`: (emin) minimum exponent before (gradual) underflow.\n*     -   `'U'`/`'u'`: (rmin) underflow threshold.\n*     -   `'L'`/`'l'`: (emax) largest exponent before overflow.\n*     -   `'O'`/`'o'`: (rmax) overflow threshold.\n*\n* @param {string} cmach - specifies the value to be returned\n* @returns {number} machine parameter\n*\n* @example\n* var out = dlamch( 'E' );\n* // returns ~1.1102230246251565e-016\n*\n* out = dlamch( 'S' );\n* // returns ~2.2250738585072014e-308\n*\n* out = dlamch( 'B' );\n* // returns 2.0\n*/\nfunction dlamch( cmach ) {\n\tcmach = lowercase( cmach.charAt( 0 ) );\n\tif ( cmach === 'e' ) {\n\t\treturn FLOAT64_EPS * 0.5;\n\t}\n\tif ( cmach === 's' ) {\n\t\treturn FLOAT64_SMALLEST_NORMAL;\n\t}\n\tif ( cmach === 'b' ) {\n\t\treturn RADIX;\n\t}\n\tif ( cmach === 'p' ) {\n\t\treturn FLOAT64_EPS * 0.5 * RADIX;\n\t}\n\tif ( cmach === 'n' ) {\n\t\treturn FLOAT64_PRECISION;\n\t}\n\tif ( cmach === 'r' ) {\n\t\treturn 1.0;\n\t}\n\tif ( cmach === 'm' ) {\n\t\treturn FLOAT64_MIN_EXPONENT + 1;\n\t}\n\tif ( cmach === 'u' ) {\n\t\treturn FLOAT64_SMALLEST_NORMAL;\n\t}\n\tif ( cmach === 'l' ) {\n\t\treturn FLOAT64_MAX_EXPONENT + 1;\n\t}\n\tif ( cmach === 'o' ) {\n\t\treturn FLOAT64_MAX;\n\t}\n\treturn 0.0;\n}\n\n\n// EXPORTS //\n\nexport default dlamch;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero row in a matrix `A`.\n*\n* ## Notes\n*\n* -   If provided an empty matrix or a matrix containing only zeros, the function returns `-1` (i.e., an invalid index).\n*\n* @private\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @returns {integer} index of the last non-zero row\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 3, 2, A, 2, 1, 0 );\n* // returns 1\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 3, 2, A, 1, 3, 0 );\n* // returns 1\n*/\nfunction iladlr( M, N, A, strideA1, strideA2, offsetA ) {\n\tvar last;\n\tvar da0;\n\tvar da1;\n\tvar S0;\n\tvar S1;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar k;\n\n\t// Check whether the matrix is an empty matrix...\n\tif ( M <= 0 || N <= 0 ) {\n\t\treturn -1;\n\t}\n\t// Compute the index of the first element in the last row:\n\tia = offsetA + ( (M-1) * strideA1 );\n\n\t// Compute the index offset for the last element in the last row:\n\tlast = ( N-1 ) * strideA2;\n\n\t// Check for the common case where the first and last elements in the last row are non-zero...\n\tif ( A[ ia ] !== 0.0 || A[ ia+last ] !== 0.0 ) {\n\t\treturn M - 1;\n\t}\n\t// Search for the last row containing at least one non-zero element...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tS0 = N;\n\t\tS1 = M;\n\n\t\t// Resolve loop offset (pointer) increments:\n\t\tda0 = strideA2;\n\t\tda1 = strideA1 - ( S0*strideA2 );\n\n\t\t// Scan a row-major linear buffer from the last indexed element to the first indexed element, always moving in the same direction when both strides are the same sign, thus ensuring cache optimal traversal...\n\t\tia += last;\n\t\tfor ( i1 = S1-1; i1 >= 0; i1-- ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tif ( A[ ia ] !== 0.0 ) {\n\t\t\t\t\t// We found a row with a non-zero element!\n\t\t\t\t\treturn i1;\n\t\t\t\t}\n\t\t\t\tia -= da0;\n\t\t\t}\n\t\t\tia -= da1;\n\t\t}\n\t\t// If we've made it here, then all entries in the matrix are zero:\n\t\treturn -1;\n\t}\n\t// Column-major...\n\tS0 = M;\n\tS1 = N;\n\n\t// Resolve loop offset (pointer) increments:\n\tda0 = strideA1;\n\tda1 = strideA2;\n\n\t// Compute the index offset for the last element in each row:\n\tlast = offsetA + ( (S0-1)*da0 );\n\n\t// Initialize an index of the last row in which a non-zero element was seen:\n\tk = -1;\n\n\t// Finding the last non-zero row when a matrix is stored in column-major order requires effectively performing a full linear scan. In order to ensure cache-efficient traversal, scan up each column (otherwise, if we went row-by-row, we'd hop around linear memory, resulting in poor cache behavior)...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t// Reset the pointer to point to the last element in the current column:\n\t\tia = last + ( i1*da1 );\n\n\t\t// Scan up the rows in a column looking for a non-zero element...\n\t\tfor ( i0 = S0-1; i0 > k; i0-- ) { // note: `k` serves as a lower row index bound, thus shrinking the number of rows we need to check when scanning columns\n\t\t\tif ( A[ ia ] !== 0.0 ) {\n\t\t\t\t// We found a non-zero element, which means we no longer have to search this row...\n\t\t\t\tk = i0;\n\t\t\t\tbreak; // note: in principle, if `k == M-1`, we could early return; however, this is a hot loop and adding an additional conditional is likely to degrade average performance in order to cater to what is effectively an edge case\n\t\t\t}\n\t\t\tia -= da0;\n\t\t}\n\t}\n\treturn k;\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/fast/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero row in a matrix `A`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fifth argument must be greater than or equal to max(1,N)\n* @returns {integer} index of the last non-zero row\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 'row-major', 3, 2, A, 2 );\n* // returns 1\n*/\nfunction iladlr( order, M, N, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tvar s;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) ) {\n\t\ts = N;\n\t} else {\n\t\ts = M;\n\t}\n\tif ( LDA < max( 1, s ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be greater than or equal to max(1,%d). Value: `%d`.', s, LDA ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport iladlr from './iladlr.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( iladlr, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero row in a matrix `A` using alternative indexing semantics.\n*\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @returns {integer} index of the last non-zero row\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 3, 2, A, 2, 1, 0 );\n* // returns 1\n*/\nfunction iladlr( M, N, A, strideA1, strideA2, offsetA ) {\n\treturn base( M, N, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to find the index of the last non-zero row in an input matrix.\n*\n* @module @stdlib/lapack/base/iladlr\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n* import iladlr from '@stdlib/lapack/base/iladlr';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 'row-major', 3, 2, A, 2 );\n* // returns 1\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar iladlr;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tiladlr = main;\n} else {\n\tiladlr = tmp;\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n\n// exports: { \"ndarray\": \"iladlr.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/iladlr/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { ndarray as iladlr } from './../../../base/iladlr';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero column in a matrix `A`.\n*\n* ## Notes\n*\n* -   If provided an empty matrix or a matrix containing only zeros, the function returns `-1` (i.e., an invalid index).\n*\n* @private\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @returns {integer} index of the last non-zero column\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 0.0, 3.0, 4.0, 0.0 ] ); // => [ [ 1.0, 2.0, 0.0 ], [ 3.0, 4.0, 0.0 ] ]\n*\n* var out = iladlc( 2, 3, A, 3, 1, 0 );\n* // returns 1\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 3.0, 2.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0, 0.0 ], [ 3.0, 4.0, 0.0 ] ]\n*\n* var out = iladlc( 2, 3, A, 1, 2, 0 );\n* // returns 1\n*/\nfunction iladlc( M, N, A, strideA1, strideA2, offsetA ) {\n\treturn iladlr( N, M, A, strideA2, strideA1, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default iladlc;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/fast/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero column in a matrix `A`.\n*\n* ## Notes\n*\n* -   If provided an empty matrix or a matrix containing only zeros, the function returns `-1` (i.e., an invalid index).\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fifth argument must be greater than or equal to max(1,N)\n* @returns {integer} index of the last non-zero column\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 0.0, 3.0, 4.0, 0.0 ] ); // => [ [ 1.0, 2.0, 0.0 ], [ 3.0, 4.0, 0.0 ] ]\n*\n* var out = iladlc( 'row-major', 2, 3, A, 3 );\n* // returns 1\n*/\nfunction iladlc( order, M, N, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tvar s;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) ) {\n\t\ts = N;\n\t} else {\n\t\ts = M;\n\t}\n\tif ( LDA < max( 1, s ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be greater than or equal to max(1,%d). Value: `%d`.', s, LDA ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default iladlc;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport iladlc from './iladlc.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( iladlc, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default iladlc;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Finds the index of the last non-zero column in a matrix `A` using alternative indexing semantics.\n*\n* ## Notes\n*\n* -   If provided an empty matrix or a matrix containing only zeros, the function returns `-1` (i.e., an invalid index).\n*\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @returns {integer} index of the last non-zero column\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 0.0, 3.0, 4.0, 0.0 ] ); // => [ [ 1.0, 2.0, 0.0 ], [ 3.0, 4.0, 0.0 ] ]\n*\n* var out = iladlc( 2, 3, A, 3, 1, 0 );\n* // returns 1\n*/\nfunction iladlc( M, N, A, strideA1, strideA2, offsetA ) {\n\treturn base( M, N, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default iladlc;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to find the index of the last non-zero column in an input matrix.\n*\n* @module @stdlib/lapack/base/iladlc\n*\n* @example\n* import Float64array from '@stdlib/array/float64';\n* import iladlc from '@stdlib/lapack/base/iladlc';\n*\n* var A = new Float64array( [ 1.0, 2.0, 0.0, 3.0, 4.0, 0.0 ] ); // => [ [ 1.0, 2.0, 0.0 ], [ 3.0, 4.0, 0.0 ] ]\n*\n* var out = iladlc( 'row-major', 2, 3, A, 3 );\n* // returns 1\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar iladlc;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tiladlc = main;\n} else {\n\tiladlc = tmp;\n}\n\n\n// EXPORTS //\n\nexport default iladlc;\n\n// exports: { \"ndarray\": \"iladlc.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/iladlc/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-len */\n\n// MODULES //\n\nimport { ndarray as iladlc } from './../../../base/iladlc';\nimport { ndarray as iladlr } from './../../../base/iladlr';\nimport { ndarray as dgemv } from '@stdlib/blas/base/dgemv';\nimport { ndarray as dger } from '@stdlib/blas/base/dger';\nimport { ndarray as daxpy } from '@stdlib/blas/base/daxpy';\nimport { ndarray as dscal } from '@stdlib/blas/base/dscal';\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether an operation should be applied to the left side.\n*\n* @private\n* @param {string} side - operation side\n* @returns {boolean} boolean indicating if an operation should be applied to the left side\n*/\nfunction isLeftSide( side ) {\n\treturn side === 'left';\n}\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @private\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {NonNegativeInteger} offsetV - starting index for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @param {Float64Array} work - workspace array\n* @param {integer} strideWork - stride length for `work`\n* @param {NonNegativeInteger} offsetWork - starting index for `work`\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'left', 4, 3, V, 1, 0, 1.0, C, 3, 1, 0, work, 1, 0 );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork ) { // eslint-disable-line max-params\n\tvar lastv;\n\tvar lastc;\n\tvar i;\n\n\tif ( tau === 0.0 ) {\n\t\treturn C;\n\t}\n\tlastc = 0;\n\tif ( isLeftSide( side ) ) {\n\t\tlastv = M;\n\t} else {\n\t\tlastv = N;\n\t}\n\t// Initialize `i` to point to the last element in `V`:\n\ti = offsetV + ( ( lastv-1 ) * strideV );\n\n\t// Move `i` to the last non-zero element in `V`, where we assume that V[0] = 1, and it is not stored, so we shouldn't access it...\n\twhile ( lastv > 0 && V[ i ] === 0.0 ) {\n\t\tlastv -= 1;\n\t\ti -= strideV;\n\t}\n\tif ( isLeftSide( side ) ) {\n\t\t// Scan for the last non-zero column in `C`:\n\t\tlastc = iladlc( lastv + 1, N, C, strideC1, strideC2, offsetC ) + 1; // adjust by `+1` to account for the difference between zero-based and one-based indexing\n\t} else {\n\t\t// Scan for the last non-zero row in `C`:\n\t\tlastc = iladlr( M, lastv + 1, C, strideC1, strideC2, offsetC ) + 1; // // adjust by `+1` to account for the difference between zero-based and one-based indexing\n\t}\n\t// Return `C` unchanged if all elements in `C` are zero...\n\tif ( lastc === 0 ) {\n\t\treturn C;\n\t}\n\tif ( isLeftSide( side ) ) {\n\t\t// Form: H*C\n\n\t\t// If `lastv = 1`, this means `V = 1`, so we just need to compute `C = H*C = (1-tau)*C`...\n\t\tif ( lastv === 0 ) {\n\t\t\t// C[0,0:lastc] = (1-tau)*C[0,0:lastc]\n\t\t\tdscal( lastc, 1.0-tau, C, strideC2, offsetC ); // scale the first row\n\t\t} else {\n\t\t\t// work[0:lastc,0] = C[0:lastv,0:lastc]^T * V[0:lastv,0]\n\n\t\t\t// work[0:lastc,0] = C[1:lastv,0:lastc]^T * V[1:lastv,0]\n\t\t\tdgemv( 'transpose', lastv-1, lastc, 1.0, C, strideC1, strideC2, offsetC+strideC1, V, strideV, offsetV+strideV, 0.0, work, strideWork, offsetWork );\n\n\t\t\t// work[0:lastc,0] += C[0,0:lastc]^T * V[0,0] = C[0,0:lastc]^T\n\t\t\tdaxpy( lastc, 1.0, C, strideC2, offsetC, work, strideWork, offsetWork ); // operates on the first row of C\n\n\t\t\t// C[0:lastv,0:lastc] = C[...] - ( tau * V[0:lastv,0] * work[0:lastc,0]^T)\n\n\t\t\t// C[0,0:lastc] = C[...] - ( tau * V[0,0] * work[0:lastc,0]^^T ) = C[...] - ( tau * work[0:lastc,0]^T )\n\t\t\tdaxpy( lastc, -tau, work, strideWork, offsetWork, C, strideC2, offsetC ); // operates on the first row of C\n\n\t\t\t// C[1:lastv,0:lastc] = C[...] - ( tau * V[1:lastv,0] * work[0:lastc,0]^T )\n\t\t\tdger( lastv-1, lastc, -tau, V, strideV, offsetV+strideV, work, strideWork, offsetWork, C, strideC1, strideC2, offsetC+strideC1 );\n\t\t}\n\t\treturn C;\n\t}\n\t// side === 'right'\n\n\t// Form: C*H\n\n\t// If `N = 1`, then `V = 1`, so we just need to compute `C = CH = C*(1-tau)`...\n\tif ( lastv === 0 ) {\n\t\t// C[0:lastc,0] = ( 1-tau ) * C[0:lastc,0]\n\t\tdscal( lastc, 1.0-tau, C, strideC1, offsetC ); // scale the first column\n\t\treturn C;\n\t}\n\t// work[0:lastc,0] = ( 1-tau ) * C[0:lastc,0]\n\n\t// work[0:lastc,0] = C[0:lastc,1:lastv] * V[1:lastv,0]\n\tdgemv( 'no-transpose', lastc, lastv-1, 1.0, C, strideC1, strideC2, offsetC+strideC2, V, strideV, offsetV+strideV, 0.0, work, strideWork, offsetWork );\n\n\t// work[0:lastc,0] += C[0:lastc,0] * V[0,0] = C[0:lastc,0]\n\tdaxpy( lastc, 1.0, C, strideC1, offsetC, work, strideWork, offsetWork ); // operates on the first column of C\n\n\t// C[0:lastc,0:lastv] = C[...] - ( tau * work[0:lastc,0] * V[0:lastv,0]^T )\n\n\t// C[0:lastc,0] = C[...] - ( tau * work[0:lastc,0] * V[0,0]^T ) = C[...] - ( tau * work[0:lastc,0] )\n\tdaxpy( lastc, -tau, work, strideWork, offsetWork, C, strideC1, offsetC ); // operates on the first column of C\n\n\t// C[0:lastc,1:lastv] = C[...] - ( tau * work[0:lastc,0] * V[1:lastv]^T )\n\tdger( lastc, lastv-1, -tau, work, strideWork, offsetWork, V, strideV, offsetV+strideV, C, strideC1, strideC2, offsetC+strideC2 );\n\n\treturn C;\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isOperationSide from '@stdlib/blas/base/assert/is-operation-side';\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport operationSides from '@stdlib/blas/base/operation-sides';\nimport join from '@stdlib/array/base/join';\nimport max from '@stdlib/math/base/special/max';\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @param {string} order - storage layout\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {PositiveInteger} LDC - stride of the first dimension of `C` (a.k.a., leading dimension of the matrix `C`)\n* @param {Float64Array} work - workspace array\n* @throws {TypeError} first argument must be a valid order\n* @throws {TypeError} second argument must be a valid side\n* @throws {RangeError} ninth argument must be greater than or equal to max(1,N)\n* @throws {RangeError} sixth argument must not be zero\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'row-major', 'left', 4, 3, V, 1, 1.0, C, 3, work );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( order, side, M, N, V, strideV, tau, C, LDC, work ) {\n\tvar sc1;\n\tvar sc2;\n\tvar ov;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( !isOperationSide( side ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be one of the following: \"%s\". Value: `%s`.', join( operationSides(), '\", \"' ), side ) );\n\t}\n\tif ( strideV === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be non-zero. Value: `%s`.', strideV ) );\n\t}\n\tif ( isRowMajor( order ) && LDC < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Ninth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDC ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsc1 = 1;\n\t\tsc2 = LDC;\n\t} else { // order === 'row-major'\n\t\tsc1 = LDC;\n\t\tsc2 = 1;\n\t}\n\tif ( side === 'left' ) {\n\t\tov = stride2offset( M, strideV );\n\t} else {\n\t\tov = stride2offset( N, strideV );\n\t}\n\treturn base( side, M, N, V, strideV, ov, tau, C, sc1, sc2, 0, work, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlarf1f from './dlarf1f.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlarf1f, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport isOperationSide from '@stdlib/blas/base/assert/is-operation-side';\nimport operationSides from '@stdlib/blas/base/operation-sides';\nimport join from '@stdlib/array/base/join';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {NonNegativeInteger} offsetV - starting index for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @param {Float64Array} work - workspace array\n* @param {integer} strideWork - stride length for `work`\n* @param {NonNegativeInteger} offsetWork - starting index for `work`\n* @throws {TypeError} first argument must be a valid side\n* @throws {RangeError} fifth argument must not be zero\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'left', 4, 3, V, 1, 0, 1.0, C, 3, 1, 0, work, 1, 0 );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork ) { // eslint-disable-line max-params\n\tif ( !isOperationSide( side ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be one of the following: \"%s\". Value: `%s`.', join( operationSides(), '\", \"' ), side ) );\n\t}\n\tif ( strideV === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be non-zero. Value: `%s`.', strideV ) );\n\t}\n\treturn base( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork );\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to apply a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* @module @stdlib/lapack/base/dlarf1f\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlarf1f from '@stdlib/lapack/base/dlarf1f';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'row-major', 'left', 4, 3, V, 1, 1.0, C, 3, work );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlarf1f;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlarf1f = main;\n} else {\n\tdlarf1f = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n\n// exports: { \"ndarray\": \"dlarf1f.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dlarf1f/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/nullary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Sets the diagonal of a double-precision floating-point matrix `A` to a specified value.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} beta - value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 6 );\n*\n* setDiagonal( 2, 3, 1.0, A, 3, 1, 0 );\n* // A => <Float64Array>[ 1.0, 0.0, 0.0, 0.0, 1.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* setDiagonal( 2, 2, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 0.0, 0.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 6 );\n*\n* setDiagonal( 3, 2, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 ]\n*/\nfunction setDiagonal( M, N, beta, A, strideA1, strideA2, offsetA ) {\n\tvar sa;\n\tvar ia;\n\tvar i;\n\n\tsa = strideA1 + strideA2;\n\tia = offsetA;\n\tfor ( i = 0; i < min( M, N ); i++ ) {\n\t\tA[ ia ] = beta;\n\t\tia += sa;\n\t}\n\treturn A;\n}\n\n/**\n* Sets all elements of a double-precision floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} alpha - value to assign to off-diagonal elements\n* @param {number} beta - value to assign to diagonal elements\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* setAll( 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* setAll( 2, 2, 2.0, 1.0, A, 1, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 2.0, 1.0 ]\n*/\nfunction setAll( M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar da0;\n\tvar da1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\n\t// Set the pointer to the first indexed element:\n\tia = offsetA;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tA[ ia ] = alpha;\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t}\n\tsetDiagonal( M, N, beta, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n* Sets the upper triangular/trapezoidal part of a double-precision floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} alpha - value to assign to off-diagonal elements\n* @param {number} beta - value to assign to diagonal elements\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* setUpper( 2, 2, 1.0, 2.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 2.0, 1.0, 0.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* setUpper( 2, 2, 1.0, 2.0, A, 1, 2, 0 );\n* // A => <Float64Array>[ 2.0, 0.0, 1.0, 2.0 ]\n*/\nfunction setUpper( M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tA[ idx ] = alpha;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t} else {\n\t\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = alpha;\n\t\t\t\tidx += strideA1;\n\t\t\t}\n\t\t\tia += strideA2;\n\t\t}\n\t}\n\tsetDiagonal( M, N, beta, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n*  Sets the lower triangular/trapezoidal part of a double-precision floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} alpha - value to assign to off-diagonal elements\n* @param {number} beta - value to assign to diagonal elements\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* setLower( 2, 2, 1.0, 2.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 2.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* setLower( 2, 2, 1.0, 2.0, A, 1, 2, 0 );\n* // A => <Float64Array>[ 2.0, 1.0, 0.0, 2.0 ]\n*/\nfunction setLower( M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = alpha;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t} else {\n\t\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA1 );\n\t\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\t\tA[ idx ] = alpha;\n\t\t\t\tidx += strideA1;\n\t\t\t}\n\t\t\tia += strideA2;\n\t\t}\n\t}\n\tsetDiagonal( M, N, beta, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n\n// MAIN //\n\n/**\n* Sets elements of matrix `A` to specified values.\n*\n* @private\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} alpha - value to assign to off-diagonal elements\n* @param {number} beta - value to assign to diagonal elements\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'all', 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'upper', 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'lower', 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 0.0, 2.0, 1.0 ]\n*/\nfunction dlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tif ( uplo === 'upper' ) {\n\t\treturn setUpper( M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n\t}\n\tif ( uplo === 'lower' ) {\n\t\treturn setLower( M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n\t}\n\treturn setAll( M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default dlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision floating-point matrix to specified values.\n*\n* @param {string} order - storage layout of `A`\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} alpha - value assigned to off-diagonal elements\n* @param {number} beta - value assigned to diagonal elements\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'row-major', 'all', 2, 2, 2.0, 1.0, A, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'row-major', 'upper', 2, 2, 2.0, 1.0, A, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'row-major', 'lower', 2, 2, 2.0, 1.0, A, 2 );\n* // A => <Float64Array>[ 1.0, 0.0, 2.0, 1.0 ]\n*/\nfunction dlaset( order, uplo, M, N, alpha, beta, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( uplo, M, N, alpha, beta, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlaset from './dlaset.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlaset, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision floating-point matrix to specified values using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} alpha - value assigned to off-diagonal elements\n* @param {number} beta - value assigned to diagonal elements\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'all', 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'upper', 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'lower', 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 0.0, 2.0, 1.0 ]\n*/\nfunction dlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\treturn base( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default dlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to set the off-diagonal elements and the diagonal elements of a double-precision floating-point matrix to specified values.\n*\n* @module @stdlib/lapack/base/dlaset\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlaset from '@stdlib/lapack/base/dlaset';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset( 'row-major', 'all', 2, 2, 2.0, 1.0, A, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 2.0, 1.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlaset from '@stdlib/lapack/base/dlaset';\n*\n* var A = new Float64Array( 4 );\n*\n* dlaset.ndarray( 'all', 2, 2, 2.0, 1.0, A, 2, 1, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 2.0, 1.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlaset;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlaset = main;\n} else {\n\tdlaset = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlaset;\n\n// exports: { \"ndarray\": \"dlaset.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dlaset/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isnan from '@stdlib/math/base/assert/is-nan';\nimport abs2 from '@stdlib/math/base/special/abs2';\nimport abs from '@stdlib/math/base/special/abs';\nimport sqrt from '@stdlib/math/base/special/sqrt';\n\n\n// VARIABLES //\n\nvar SBIG = 1.11137937474253874e-162;\nvar SSML = 4.49891379454319638e+161;\nvar TBIG = 1.99791907220223503e+146;\nvar TSML = 1.49166814624004135e-154;\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form.\n*\n* @private\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @param {Float64Array} out - output array\n* @param {integer} strideOut - stride length for `out`\n* @param {NonNegativeInteger} offsetOut - starting index for `out`\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq( 4, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut ) { // eslint-disable-line max-len\n\tvar notbig;\n\tvar abig;\n\tvar asml;\n\tvar amed;\n\tvar ymin;\n\tvar ymax;\n\tvar ax;\n\tvar ox;\n\tvar i;\n\n\tif ( isnan( scale ) || isnan( sumsq ) ) {\n\t\treturn out;\n\t}\n\tif ( sumsq === 0.0 ) {\n\t\tscale = 1.0;\n\t}\n\tif ( scale === 0.0 ) {\n\t\tscale = 1.0;\n\t\tsumsq = 0.0;\n\t}\n\tif ( N <= 0 ) {\n\t\tout[ offsetOut ] = scale;\n\t\tout[ offsetOut + strideOut ] = sumsq;\n\t\treturn out;\n\t}\n\t/*\n\t* Compute the sum of squares in 3 accumulators:\n\t*\n\t* -   `abig`: sums of squares scaled down to avoid overflow\n\t* -   `asml`: sums of squares scaled up to avoid underflow\n\t* -   `amed`: sums of squares that do not require scaling\n\t*\n\t* The thresholds and multipliers are\n\t*\n\t* -   `tbig`: values bigger than this are scaled down by `sbig`\n\t* -   `tsml`: values smaller than this are scaled up by `ssml`\n\t*/\n\tnotbig = true;\n\tasml = 0.0;\n\tamed = 0.0;\n\tabig = 0.0;\n\tox = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tax = abs( X[ ox ] );\n\t\tif ( ax > TBIG ) {\n\t\t\tabig += abs2( ax*SBIG );\n\t\t\tnotbig = false;\n\t\t} else if ( ax < TSML ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tasml += abs2( ax*SSML );\n\t\t\t}\n\t\t} else {\n\t\t\tamed += abs2( ax );\n\t\t}\n\t\tox += strideX;\n\t}\n\t// Put the existing sum of squares into one of the accumulators...\n\tif ( sumsq > 0.0 ) {\n\t\tax = scale * sqrt( sumsq );\n\t\tif ( ax > TBIG ) {\n\t\t\tif ( scale > 1.0 ) {\n\t\t\t\tscale *= SBIG;\n\t\t\t\tabig += scale * ( scale * sumsq );\n\t\t\t} else {\n\t\t\t\t// `sumsq > tbig^2` => `(sbig * (sbig * sumsq))` is representable\n\t\t\t\tabig += scale * ( scale * ( SBIG * ( SBIG*sumsq ) ) );\n\t\t\t}\n\t\t} else if ( ax < TSML ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tif ( scale < 1.0 ) {\n\t\t\t\t\tscale *= SSML;\n\t\t\t\t\tasml += scale * ( scale*sumsq );\n\t\t\t\t} else {\n\t\t\t\t\t// `sumsq < tsml^2` => `(ssml * (ssml * sumsq))` is representable\n\t\t\t\t\tasml += scale * ( scale * ( SSML * ( SSML*sumsq ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tamed += scale * ( scale*sumsq );\n\t\t}\n\t}\n\t// Combine `abig` and `amed` or `amed` and `asml` if more than one accumulator was used...\n\tif ( abig > 0.0 ) {\n\t\t// Combine `abig` and `amed` if `abig > 0`...\n\t\tif ( amed > 0.0 || isnan( amed ) ) {\n\t\t\tabig += ( amed*SBIG ) * SBIG;\n\t\t}\n\t\tout[ offsetOut ] = 1.0 / SBIG;\n\t\tout[ offsetOut + strideOut ] = abig;\n\t\treturn out;\n\t}\n\tif ( asml > 0.0 ) {\n\t\t// Combine `amed` and `asml` if `asml > 0`...\n\t\tif ( amed > 0.0 || isnan( amed ) ) {\n\t\t\tamed = sqrt( amed );\n\t\t\tasml = sqrt( asml ) / SSML;\n\t\t\tif ( asml > amed ) {\n\t\t\t\tymin = amed;\n\t\t\t\tymax = asml;\n\t\t\t} else {\n\t\t\t\tymin = asml;\n\t\t\t\tymax = amed;\n\t\t\t}\n\t\t\tscale = 1.0;\n\t\t\tsumsq = abs2( ymax ) * ( 1.0 + abs2( ymin/ymax ) );\n\t\t} else {\n\t\t\tscale = 1.0 / SSML;\n\t\t\tsumsq = asml;\n\t\t}\n\t\tout[ offsetOut ] = scale;\n\t\tout[ offsetOut + strideOut ] = sumsq;\n\t\treturn out;\n\t}\n\t// Otherwise all values are mid-range or zero...\n\tout[ offsetOut ] = 1.0;\n\tout[ offsetOut + strideOut ] = amed;\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Float64Array from '@stdlib/array/float64';\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form.\n*\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* var out = dlassq( 4, X, 1, 1.0, 0.0 );\n* // returns <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, scale, sumsq ) {\n\tvar out;\n\tvar ox;\n\n\tox = stride2offset( N, strideX );\n\tout = new Float64Array( 2 );\n\treturn base( N, X, strideX, ox, scale, sumsq, out, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlassq from './dlassq.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlassq, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns an updated sum of squares represented in scaled form using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Float64Array} X - input array\n* @param {integer} strideX - stride length for `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @param {number} scale - scaling factor\n* @param {number} sumsq - basic sum of squares from which output is factored out\n* @param {Float64Array} out - output array\n* @param {integer} strideOut - stride length for `out`\n* @param {NonNegativeInteger} offsetOut - starting index for `out`\n* @returns {Float64Array} output array\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq( 4, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\nfunction dlassq( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut ) {\n\treturn base( N, X, strideX, offsetX, scale, sumsq, out, strideOut, offsetOut );\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to return an updated sum of squares represented in scaled form.\n*\n* @module @stdlib/lapack/base/dlassq\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlassq from '@stdlib/lapack/base/dlassq';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* var out = dlassq( X.length, X, 1, 1.0, 0.0 );\n* // returns <Float64Array>[ 1.0, 30.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dlassq from '@stdlib/lapack/base/dlassq';\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var out = new Float64Array( [ 0.0, 0.0 ] );\n*\n* dlassq.ndarray( X.length, X, 1, 0, 1.0, 0.0, out, 1, 0 );\n* // out => <Float64Array>[ 1.0, 30.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlassq;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlassq = main;\n} else {\n\tdlassq = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlassq;\n\n// exports: { \"ndarray\": \"dlassq.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dlassq/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport floor from '@stdlib/math/base/special/floor';\nimport { ndarray as dswap } from '@stdlib/blas/base/dswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `dswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tdswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\t\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dlaswp from './dlaswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float64Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction dlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack/base/dlaswp\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float64Array from '@stdlib/array/float64';\n* import dlaswp from '@stdlib/lapack/base/dlaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* dlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlaswp = main;\n} else {\n\tdlaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlaswp;\n\n// exports: { \"ndarray\": \"dlaswp.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dlaswp/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @private\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tvar id;\n\tvar ie;\n\tvar v;\n\tvar i;\n\n\tif ( N === 0 ) {\n\t\treturn 0;\n\t}\n\tie = offsetE;\n\tid = offsetD;\n\n\t// Compute the `L * D * L^T` factorization of `A`...\n\tfor ( i = 0; i < N-1; i++ ) {\n\t\t// If `D[k] <= 0`, then the matrix is not positive definite...\n\t\tif ( D[ id ] <= 0.0 ) {\n\t\t\treturn i+1;\n\t\t}\n\t\t// Solve for E[k] and D[k+1]...\n\t\tv = E[ ie ];\n\t\tE[ ie ] = v / D[ id ];\n\n\t\tid += strideD;\n\t\tD[ id ] -= E[ ie ] * v;\n\n\t\tie += strideE;\n\t}\n\t// Check `D[k]` for positive definiteness...\n\tif ( D[ id ] <= 0.0 ) {\n\t\treturn N;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, E );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, E ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, 1, 0, E, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport dpttrf from './dpttrf.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dpttrf, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A` using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float64Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float64Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\nfunction dpttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, strideD, offsetD, E, strideE, offsetE );\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to compute the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @module @stdlib/lapack/base/dpttrf\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dpttrf from '@stdlib/lapack/base/dpttrf';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf( 3, D, E );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n* import dpttrf from '@stdlib/lapack/base/dpttrf';\n*\n* var D = new Float64Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float64Array( [ 1.0, 2.0 ] );\n*\n* dpttrf.ndarray( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float64Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float64Array>[ 0.25, ~0.4210 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dpttrf;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdpttrf = main;\n} else {\n\tdpttrf = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dpttrf;\n\n// exports: { \"ndarray\": \"dpttrf.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/dpttrf/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float32Array} `out`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction sgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\tvar isrm;\n\tvar da0;\n\tvar da1;\n\tvar do0;\n\tvar do1;\n\tvar ia;\n\tvar io;\n\tvar i0;\n\tvar i1;\n\tvar S0;\n\tvar S1;\n\n\t// Note on variable naming convention: S#, da#, do#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Perform loop interchange based on the layout format of the output matrix...\n\tisrm = isRowMajor( [ strideO1, strideO2 ] );\n\tif ( isrm ) {\n\t\t// For row-major matrices, the last dimensions have the fastest changing indices...\n\t\tS0 = M;\n\t\tS1 = N;\n\t\tda0 = strideA1;                   // offset increment for innermost loop\n\t\tda1 = strideA2 - ( S0*strideA1 ); // offset increment for outermost loop\n\t\tdo0 = strideO2;\n\t\tdo1 = strideO1 - ( S0*strideO2 );\n\t} else {\n\t\t// For column-major matrices, the first dimensions have the fastest changing indices...\n\t\tS0 = N;\n\t\tS1 = M;\n\t\tda0 = strideA2;                   // offset increment for innermost loop\n\t\tda1 = strideA1 - ( S0*strideA2 ); // offset increment for outermost loop\n\t\tdo0 = strideO1;\n\t\tdo1 = strideO2 - ( S0*strideO1 );\n\t}\n\tia = offsetA;\n\tio = offsetO;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tout[ io ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tio += do0;\n\t\t}\n\t\tia += da1;\n\t\tio += do1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa.\n*\n* @param {string} order - storage layout\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float32Array} out - output matrix\n* @param {PositiveInteger} LDO - stride of the first dimension of `out` (a.k.a., leading dimension of the matrix `out`)\n* @throws {TypeError} first argument must be a valid order\n* @returns {Float32Array} `out`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction sgetrans( order, M, N, A, LDA, out, LDO ) {\n\tvar sa1;\n\tvar sa2;\n\tvar so1;\n\tvar so2;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tso1 = 1;\n\t\tso2 = LDO;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tso1 = LDO;\n\t\tso2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0, out, so1, so2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport sgetrans from './sgetrans.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( sgetrans, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Converts a matrix from row-major layout to column-major layout or vice versa using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} out - output matrix\n* @param {integer} strideO1 - stride of the first dimension of `out`\n* @param {integer} strideO2 - stride of the second dimension of `out`\n* @param {NonNegativeInteger} offsetO - starting index for `out`\n* @returns {Float32Array} `out`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\nfunction sgetrans( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO ) {\n\treturn base( M, N, A, strideA1, strideA2, offsetA, out, strideO1, strideO2, offsetO );\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to convert a matrix from row-major layout to column-major layout or vice versa.\n*\n* @module @stdlib/lapack/base/sge-trans\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import sgetrans from '@stdlib/lapack/base/sge-trans';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans( 'row-major', 2, 3, A, 3, out, 2 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import sgetrans from '@stdlib/lapack/base/sge-trans';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n* var out = new Float32Array( 6 );\n*\n* out = sgetrans.ndarray( 2, 3, A, 3, 1, 0, out, 2, 1, 0 );\n* // returns <Float32Array>[ 1.0, 4.0, 2.0, 5.0, 3.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar sgetrans;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tsgetrans = main;\n} else {\n\tsgetrans = tmp;\n}\n\n\n// EXPORTS //\n\nexport default sgetrans;\n\n// exports: { \"ndarray\": \"sgetrans.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/sge-trans/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 1.0, 4.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 3.0, 2.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 3.0, 2.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 4.0, 1.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 1.0, 4.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyAll( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 2.0, 3.0, 1.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 1.0, 0.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 4.0, 0.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 3.0, 0.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 3.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 4.0, 0.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyUpper( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 2.0, 0.0, 1.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 2, -1, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 0.0, 4.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -2, 1, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -2, -1, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 0.0, 2.0, 1.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 1, 2, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 2.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -1, 2, 1, B, 2, 1, 0 );\n* // B => <Float32Array>[ 2.0, 0.0, 1.0, 3.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, 1, -2, 2, B, 2, 1, 0 );\n* // B => <Float32Array>[ 3.0, 0.0, 4.0, 2.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* copyLower( 2, 2, A, -1, -2, 3, B, 2, 1, 0 );\n* // B => <Float32Array>[ 4.0, 0.0, 3.0, 1.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ ib+(i0*strideB2) ] = A[ ia+(i0*strideA2) ];\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ ib+(i0*strideB1) ] = A[ ia+(i0*strideA1) ];\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction slacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( uplo === 'upper' ) {\n\t\treturn copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\tif ( uplo === 'lower' ) {\n\t\treturn copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n\t}\n\treturn copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float32Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 0.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 0.0, 3.0, 4.0 ]\n*/\nfunction slacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport slacpy from './slacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( slacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float32Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float32Array} `B`\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 0.0, 5.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 0.0, 4.0, 5.0 ]\n*/\nfunction slacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/slacpy\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import slacpy from '@stdlib/lapack/base/slacpy';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float32Array( 4 );\n*\n* slacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n* // B => <Float32Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import slacpy from '@stdlib/lapack/base/slacpy';\n*\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );\n* var B = new Float32Array( 6 );\n*\n* slacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n* // B => <Float32Array>[ 0.0, 0.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar slacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tslacpy = main;\n} else {\n\tslacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default slacpy;\n\n// exports: { \"ndarray\": \"slacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/slacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport floor from '@stdlib/math/base/special/floor';\nimport { ndarray as sswap } from '@stdlib/blas/base/sswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float32Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction slaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `sswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tsswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\t\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\t\t\t\t\ttmp = A[ ia1+o ];\n\t\t\t\t\tA[ ia1+o ] = A[ ia2+o ];\n\t\t\t\t\tA[ ia2+o ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float32Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Float32Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction slaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport slaswp from './slaswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( slaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float32Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Float32Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\nfunction slaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack/base/slaswp\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Float32Array from '@stdlib/array/float32';\n* import slaswp from '@stdlib/lapack/base/slaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Float32Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 5.0, 6.0 ] ]\n*\n* slaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Float32Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar slaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tslaswp = main;\n} else {\n\tslaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default slaswp;\n\n// exports: { \"ndarray\": \"slaswp.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/slaswp/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport f32 from '@stdlib/number/float64/base/to-float32';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @private\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tvar id;\n\tvar ie;\n\tvar v;\n\tvar i;\n\n\tif ( N === 0 ) {\n\t\treturn 0;\n\t}\n\tie = offsetE;\n\tid = offsetD;\n\n\t// Compute the `L * D * L^T` factorization of `A`...\n\tfor ( i = 0; i < N-1; i++ ) {\n\t\t// If `D[k] <= 0`, then the matrix is not positive definite...\n\t\tif ( D[ id ] <= 0.0 ) {\n\t\t\treturn i+1;\n\t\t}\n\t\t// Solve for E[k] and D[k+1]...\n\t\tv = E[ ie ];\n\t\tE[ ie ] = f32( v / D[ id ] );\n\n\t\tid += strideD;\n\t\tD[ id ] = f32( D[ id ] - f32( E[ ie ] * v ) );\n\n\t\tie += strideE;\n\t}\n\t// Check `D[k]` for positive definiteness...\n\tif ( D[ id ] <= 0.0 ) {\n\t\treturn N;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, E );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, E ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, 1, 0, E, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport spttrf from './spttrf.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( spttrf, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A` using alternative indexing semantics.\n*\n* @param {NonNegativeInteger} N - order of matrix `A`\n* @param {Float32Array} D - the `N` diagonal elements of `A`\n* @param {integer} strideD - stride length for `D`\n* @param {NonNegativeInteger} offsetD - starting index of `D`\n* @param {Float32Array} E - the `N-1` subdiagonal elements of `A`\n* @param {integer} strideE - stride length for `E`\n* @param {NonNegativeInteger} offsetE - starting index of `E`\n* @throws {RangeError} first argument must be a nonnegative integer\n* @returns {integer} status code\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\nfunction spttrf( N, D, strideD, offsetD, E, strideE, offsetE ) {\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( N, D, strideD, offsetD, E, strideE, offsetE );\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to compute the `L * D * L^T` factorization of a real symmetric positive definite tridiagonal matrix `A`.\n*\n* @module @stdlib/lapack/base/spttrf\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import spttrf from '@stdlib/lapack/base/spttrf';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf( 3, D, E );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*\n* @example\n* import Float32Array from '@stdlib/array/float32';\n* import spttrf from '@stdlib/lapack/base/spttrf';\n*\n* var D = new Float32Array( [ 4.0, 5.0, 6.0 ] );\n* var E = new Float32Array( [ 1.0, 2.0 ] );\n*\n* spttrf.ndarray( 3, D, 1, 0, E, 1, 0 );\n* // D => <Float32Array>[ 4, 4.75, ~5.15789 ]\n* // E => <Float32Array>[ 0.25, ~0.4210 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar spttrf;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tspttrf = main;\n} else {\n\tspttrf = tmp;\n}\n\n\n// EXPORTS //\n\nexport default spttrf;\n\n// exports: { \"ndarray\": \"spttrf.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/spttrf/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a double-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - input array\n* @param {integer} strideZX - `zx` stride length\n* @param {NonNegativeInteger} offsetZX - starting `zx` index\n* @returns {Complex128Array} input array\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* zlacgv( 3, zx, 1, 0 );\n*\n* var z = zx.get( 0 );\n* // returns <Complex128>[ 1.0, -2.0 ]\n*/\nfunction zlacgv( N, zx, strideZX, offsetZX ) {\n\tvar zx64;\n\tvar ix;\n\tvar sx;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn zx;\n\t}\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tzx64 = reinterpret( zx, 0 );\n\n\t// Adjust the strides and offset:\n\tsx = strideZX * 2;\n\tix = ( offsetZX * 2 ) + 1; // index of the first imaginary component\n\n\t// Conjugate each element by negating the imaginary components...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tzx64[ ix ] = -zx64[ ix ];\n\t\tix += sx;\n\t}\n\treturn zx;\n}\n\n\n// EXPORTS //\n\nexport default zlacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Conjugates each element in a double-precision complex floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - input array\n* @param {integer} strideZX - `zx` stride length\n* @returns {Complex128Array} input array\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* zlacgv( 3, zx, 1 );\n*\n* var z = zx.get( 0 );\n* // returns <Complex128>[ 1.0, -2.0 ]\n*/\nfunction zlacgv( N, zx, strideZX ) {\n\treturn ndarray( N, zx, strideZX, stride2offset( N, strideZX ) );\n}\n\n\n// EXPORTS //\n\nexport default zlacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zlacgv from './zlacgv.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlacgv, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlacgv;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport loopOrder from '@stdlib/ndarray/base/unary-loop-interchange-order';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Copies all of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 5.0, 6.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 5.0, 6.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 7.0, 8.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 1.0, 2.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyAll( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 3.0, 4.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyAll( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar da0;\n\tvar da1;\n\tvar db0;\n\tvar db1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar sb;\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ], [ strideB1, strideB2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\tsb = o.sy;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\tdb0 = sb[ 0 ];\n\tdb1 = sb[ 1 ] - ( S0*sb[0] );\n\n\t// Set the pointers to the first indexed elements in the respective matrices...\n\tia = offsetA;\n\tib = offsetB;\n\n\t// Iterate over the matrix dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tB[ ib ] = A[ ia ];\n\t\t\tB[ ib+1 ] = A[ ia+1 ];\n\t\t\tia += da0;\n\t\t\tib += db0;\n\t\t}\n\t\tia += da1;\n\t\tib += db1;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the upper triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix view\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 7.0, 8.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 5.0, 6.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 5.0, 6.0, 0.0, 0.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 7.0, 8.0, 0.0, 0.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyUpper( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 3.0, 4.0, 0.0, 0.0, 1.0, 2.0 ]\n*/\nfunction copyUpper( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia + ( i1*strideA2 );\n\t\t\tjb = ib + ( i1*strideB2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tjb = ib;\n\t\tja = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n/**\n* Copies the lower triangular/trapezoidal part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 4, 2, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 5.0, 6.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 4, -2, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 7.0, 8.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -4, 2, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -4, -2, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 0.0, 0.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 2, 4, 0, B, 4, 2, 0 );\n* // B => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 7.0, 8.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -2, 4, 2, B, 4, 2, 0 );\n* // B => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 5.0, 6.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, 2, -4, 4, B, 4, 2, 0 );\n* // B => <Float64Array>[ 5.0, 6.0, 0.0, 0.0, 7.0, 8.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Float64Array( 8 );\n*\n* copyLower( 2, 2, A, -2, -4, 6, B, 4, 2, 0 );\n* // B => <Float64Array>[ 7.0, 8.0, 0.0, 0.0, 5.0, 6.0, 1.0, 2.0 ]\n*/\nfunction copyLower( M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar ia;\n\tvar ib;\n\tvar i0;\n\tvar i1;\n\tvar ja;\n\tvar jb;\n\n\tia = offsetA;\n\tib = offsetB;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tja = ia;\n\t\t\tjb = ib;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tB[ jb ] = A[ ja ];\n\t\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\t\tja += strideA2;\n\t\t\t\tjb += strideB2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t\tib += strideB1;\n\t\t}\n\t\treturn B;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tja = ia + ( i1*strideA1 );\n\t\tjb = ib + ( i1*strideB1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tB[ jb ] = A[ ja ];\n\t\t\tB[ jb+1 ] = A[ ja+1 ];\n\t\t\tja += strideA1;\n\t\t\tjb += strideB1;\n\t\t}\n\t\tia += strideA2;\n\t\tib += strideB2;\n\t}\n\treturn B;\n}\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @private\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex128Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex128Array} `B`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'all', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex128>[ 5.0, 6.0 ]\n*\n* z = B.get( 3 );\n* // returns <Complex128>[ 7.0, 8.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'upper', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n* // B => <Complex128Array>\n*\n* var z = B.get( 0 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* z = B.get( 3 );\n* // returns <Complex128>[ 7.0, 8.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'lower', 2, 2, A, 2, 1, 0, B, 2, 1, 0 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex128>[ 5.0, 6.0 ]\n*\n* z = B.get( 3 );\n* // returns <Complex128>[ 7.0, 8.0 ]\n*/\nfunction zlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar viewA;\n\tvar viewB;\n\n\t// Reinterpret the input and output arrays as real-valued arrays of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\tviewB = reinterpret( B, 0 );\n\n\t// Adjust the strides and offsets accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\tstrideB1 *= 2;\n\tstrideB2 *= 2;\n\n\toffsetA *= 2;\n\toffsetB *= 2;\n\n\tif ( uplo === 'upper' ) {\n\t\tcopyUpper( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else if ( uplo === 'lower' ) {\n\t\tcopyLower( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t} else {\n\t\tcopyAll( M, N, viewA, strideA1, strideA2, offsetA, viewB, strideB1, strideB2, offsetB );\n\t}\n\treturn B;\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B`.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Complex128Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} sixth argument must be greater than or equal to `N`\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex128Array} `B`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'upper', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = B.get( 2 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'lower', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*/\nfunction zlacpy( order, uplo, M, N, A, LDA, B, LDB ) {\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tif ( LDB < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDB ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( uplo, M, N, A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zlacpy from './zlacpy.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlacpy, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Copies all or part of a matrix `A` to another matrix `B` using alternative indexing semantics.\n*\n* @param {string} uplo - specifies whether to copy the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Complex128Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Complex128Array} `B`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy( 'upper', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = B.get( 4 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy( 'lower', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = B.get( 1 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*/\nfunction zlacpy( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) { // eslint-disable-line max-len, max-params\n\treturn base( uplo, M, N, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to copy all or part of a matrix `A` to another matrix `B`.\n*\n* @module @stdlib/lapack/base/zlacpy\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import real from '@stdlib/complex/float64/real';\n* import imag from '@stdlib/complex/float64/imag';\n* import zlacpy from '@stdlib/lapack/base/zlacpy';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var B = new Complex128Array( 4 );\n*\n* zlacpy( 'row-major', 'all', 2, 2, A, 2, B, 2 );\n*\n* var z = B.get( 0 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import zlacpy from '@stdlib/lapack/base/zlacpy';\n*\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 ] );\n* var B = new Complex128Array( 12 );\n*\n* zlacpy.ndarray( 'all', 2, 2, A, 2, 1, 1, B, 2, 1, 2 );\n*\n* var z = B.get( 2 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar zlacpy;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlacpy = main;\n} else {\n\tzlacpy = tmp;\n}\n\n\n// EXPORTS //\n\nexport default zlacpy;\n\n// exports: { \"ndarray\": \"zlacpy.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/zlacpy/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\nimport loopOrder from '@stdlib/ndarray/base/nullary-loop-interchange-order';\nimport real from '@stdlib/complex/float64/real';\nimport imag from '@stdlib/complex/float64/imag';\nimport min from '@stdlib/math/base/special/fast/min';\n\n\n// FUNCTIONS //\n\n/**\n* Sets the diagonal of a double-precision complex floating-point matrix `A` to a specified value.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 3, 1.0, 2.0, A, 6, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 3, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, 0.0, 0.0 ]\n*/\nfunction setDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA ) {\n\tvar sa;\n\tvar ia;\n\tvar i;\n\n\tsa = strideA1 + strideA2;\n\tia = offsetA;\n\tfor ( i = 0; i < min( M, N ); i++ ) {\n\t\tA[ ia ] = breal;\n\t\tA[ ia+1 ] = bimag;\n\t\tia += sa;\n\t}\n\treturn A;\n}\n\n/**\n* Sets all elements of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setAll( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar da0;\n\tvar da1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\n\t// Set the pointer to the first indexed element:\n\tia = offsetA;\n\n\t// Fill the array with a scalar value...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tA[ ia ] = areal;\n\t\t\tA[ ia+1 ] = aimag;\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t}\n\t// Replace the diagonal:\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\n\treturn A;\n}\n\n/**\n* Sets the upper triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*/\nfunction setUpper( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n* Sets the lower triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array/float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setLower( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia + ( i1*strideA1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n\n// MAIN //\n\n/**\n* Sets elements of matrix `A` to specified values.\n*\n* @private\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar viewA;\n\tvar ar;\n\tvar ai;\n\tvar br;\n\tvar bi;\n\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\n\t// Adjust the strides and offset accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\n\toffsetA *= 2;\n\n\t// Decompose the scalars to real and imaginary components:\n\tar = real( alpha );\n\tai = imag( alpha );\n\tbr = real( beta );\n\tbi = imag( beta );\n\n\tif ( uplo === 'upper' ) {\n\t\tsetUpper( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else if ( uplo === 'lower' ) {\n\t\tsetLower( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else {\n\t\tsetAll( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} order - storage layout of `A`\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'upper', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'lower', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 1 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*/\nfunction zlaset( order, uplo, M, N, alpha, beta, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( uplo, M, N, alpha, beta, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zlaset from './zlaset.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlaset, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = A.get( 3 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*\n* z = A.get( 3 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* z = A.get( 2 );\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* z = A.get( 3 );\n* // returns <Complex128>[ 1.0, 2.0 ]\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\treturn base( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to set the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @module @stdlib/lapack/base/zlaset\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import zlaset from '@stdlib/lapack/base/zlaset';\n*\n* var A = new Complex128Array( 4 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n* import zlaset from '@stdlib/lapack/base/zlaset';\n*\n* var A = new Complex128Array( 5 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset.ndarray( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>[ 3.0, 4.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar zlaset;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlaset = main;\n} else {\n\tzlaset = tmp;\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n\n// exports: { \"ndarray\": \"zlaset.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/zlaset/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major';\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\nimport floor from '@stdlib/math/base/special/floor';\nimport { ndarray as zswap } from '@stdlib/blas/base/zswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar viewA;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `zswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tzswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\tviewA = reinterpret( A, 0 );\n\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\toffsetA *= 2;\n\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas/base/assert/is-layout';\nimport isRowMajor from '@stdlib/ndarray/base/assert/is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray/base/assert/is-column-major-string';\nimport max from '@stdlib/math/base/special/max';\nimport format from '@stdlib/string/format';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zlaswp from './zlaswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex128Array from '@stdlib/array/complex128';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack/base/zlaswp\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex128Array from '@stdlib/array/complex128';\n* import zlaswp from '@stdlib/lapack/base/zlaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*\n* @example\n* import Int32Array from '@stdlib/array/int32';\n* import Complex128Array from '@stdlib/array/complex128';\n* import zlaswp from '@stdlib/lapack/base/zlaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp.ndarray( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils/try-require';\nimport isError from '@stdlib/assert/is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar zlaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlaswp = main;\n} else {\n\tzlaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n\n// exports: { \"ndarray\": \"zlaswp.ndarray\" }\n","export default '/home/runner/work/lapack/lapack/base/zlaswp/lib'","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided/base/reinterpret-complex128';\nimport real from '@stdlib/complex/float64/real';\nimport imag from '@stdlib/complex/float64/imag';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - first input array\n* @param {integer} strideX - `zx` stride length\n* @param {NonNegativeInteger} offsetX - starting `zx` index\n* @param {Complex128Array} zy - second input array\n* @param {integer} strideY - `zy` stride length\n* @param {NonNegativeInteger} offsetY - starting `zy` index\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex128} s - sine of the angle of rotation\n* @returns {Complex128Array} `zy`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var zy = new Complex128Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex128( 0.3, 0.4 );\n*\n* zrot( zx.length, zx, 1, 0, zy, 1, 0, 0.8, s );\n*\n* var z = zy.get( 0 );\n* // returns <Complex128>[ ~-1.1, ~-0.2 ]\n*\n* z = zx.get( 0 );\n* // returns <Complex128>[ ~0.8, ~1.6 ]\n*/\nfunction zrot( N, zx, strideX, offsetX, zy, strideY, offsetY, c, s ) {\n\tvar viewX;\n\tvar viewY;\n\tvar sr;\n\tvar si;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar yr;\n\tvar yi;\n\tvar xr;\n\tvar xi;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn zy;\n\t}\n\tviewX = reinterpret( zx, 0 );\n\tviewY = reinterpret( zy, 0 );\n\n\tix = offsetX * 2;\n\tiy = offsetY * 2;\n\n\tsx = strideX * 2;\n\tsy = strideY * 2;\n\n\tsr = real( s );\n\tsi = imag( s );\n\n\tfor ( i = 0; i < N; i++ ) {\n\t\tyr = viewY[ iy ];\n\t\tyi = viewY[ iy+1 ];\n\t\txr = viewX[ ix ];\n\t\txi = viewX[ ix+1 ];\n\n\t\t// Compute tmp = c * zx[ ix ] + s * zy[ iy ]\n\t\tviewX[ ix ] = ( c*xr ) + ( ( sr*yr ) - ( si*yi ) );\n\t\tviewX[ ix+1 ] = ( c*xi ) + ( ( sr*yi ) + ( si*yr ) );\n\n\t\t// Compute zy[ iy ] = c * zy[ iy ] - conj(s) * zx[ ix ]\n\t\tviewY[ iy ] = ( c*yr ) - ( ( sr*xr ) + ( si*xi ) );\n\t\tviewY[ iy+1 ] = ( c*yi ) - ( ( sr*xi ) - ( si*xr ) );\n\n\t\tix += sx;\n\t\tiy += sy;\n\t}\n\treturn zy;\n}\n\n\n// EXPORTS //\n\nexport default zrot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided/base/stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Applies a plane rotation with real cosine and complex sine.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - first input array\n* @param {integer} strideX - `zx` stride length\n* @param {Complex128Array} zy - second input array\n* @param {integer} strideY - `zy` stride length\n* @param {number} c - cosine of the angle of rotation\n* @param {Complex128} s - sine of the angle of rotation\n* @returns {Complex128Array} `zy`\n*\n* @example\n* import Complex128Array from '@stdlib/array/complex128';\n* import Complex128 from '@stdlib/complex/float64/ctor';\n*\n* var zx = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var zy = new Complex128Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n* var s = new Complex128( 0.3, 0.4 );\n*\n* zrot( zx.length, zx, 1, zy, 1, 0.8, s );\n*\n* var z = zy.get( 0 );\n* // returns <Complex128>[ ~-1.1, ~-0.2 ]\n*\n* z = zx.get( 0 );\n* // returns <Complex128>[ ~0.8, ~1.6 ]\n*/\nfunction zrot( N, zx, strideX, zy, strideY, c, s ) {\n\tvar ix = stride2offset( N, strideX );\n\tvar iy = stride2offset( N, strideY );\n\treturn ndarray( N, zx, strideX, ix, zy, strideY, iy, c, s );\n}\n\n\n// EXPORTS //\n\nexport default zrot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport zrot from './zrot.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zrot, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zrot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/*\n* When adding modules to the namespace, ensure that they are added in alphabetical order according to module name.\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-read-only-property';\n\n\n// MAIN //\n\n/**\n* Top-level namespace.\n*\n* @namespace ns\n*/\nvar ns = {};\n\n/**\n* @name clacgv\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/clacgv}\n*/\nimport clacgv from './../../base/clacgv';\nsetReadOnly( ns, 'clacgv', clacgv );\n\n/**\n* @name clacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/clacpy}\n*/\nimport clacpy from './../../base/clacpy';\nsetReadOnly( ns, 'clacpy', clacpy );\n\n/**\n* @name claset\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/claset}\n*/\nimport claset from './../../base/claset';\nsetReadOnly( ns, 'claset', claset );\n\n/**\n* @name claswp\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/claswp}\n*/\nimport claswp from './../../base/claswp';\nsetReadOnly( ns, 'claswp', claswp );\n\n/**\n* @name crot\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/crot}\n*/\nimport crot from './../../base/crot';\nsetReadOnly( ns, 'crot', crot );\n\n/**\n* @name dgetrans\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dge-trans}\n*/\nimport dgetrans from './../../base/dge-trans';\nsetReadOnly( ns, 'dgetrans', dgetrans );\n\n/**\n* @name dgttrf\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dgttrf}\n*/\nimport dgttrf from './../../base/dgttrf';\nsetReadOnly( ns, 'dgttrf', dgttrf );\n\n/**\n* @name dlacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlacpy}\n*/\nimport dlacpy from './../../base/dlacpy';\nsetReadOnly( ns, 'dlacpy', dlacpy );\n\n/**\n* @name dladiv\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dladiv}\n*/\nimport dladiv from './../../base/dladiv';\nsetReadOnly( ns, 'dladiv', dladiv );\n\n/**\n* @name dlamch\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlamch}\n*/\nimport dlamch from './../../base/dlamch';\nsetReadOnly( ns, 'dlamch', dlamch );\n\n/**\n* @name dlapy2\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlapy2}\n*/\nimport dlapy2 from './../../base/dlapy2';\nsetReadOnly( ns, 'dlapy2', dlapy2 );\n\n/**\n* @name dlapy3\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlapy3}\n*/\nimport dlapy3 from './../../base/dlapy3';\nsetReadOnly( ns, 'dlapy3', dlapy3 );\n\n/**\n* @name dlarf1f\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlarf1f}\n*/\nimport dlarf1f from './../../base/dlarf1f';\nsetReadOnly( ns, 'dlarf1f', dlarf1f );\n\n/**\n* @name dlaset\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlaset}\n*/\nimport dlaset from './../../base/dlaset';\nsetReadOnly( ns, 'dlaset', dlaset );\n\n/**\n* @name dlassq\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlassq}\n*/\nimport dlassq from './../../base/dlassq';\nsetReadOnly( ns, 'dlassq', dlassq );\n\n/**\n* @name dlaswp\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dlaswp}\n*/\nimport dlaswp from './../../base/dlaswp';\nsetReadOnly( ns, 'dlaswp', dlaswp );\n\n/**\n* @name dpttrf\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/dpttrf}\n*/\nimport dpttrf from './../../base/dpttrf';\nsetReadOnly( ns, 'dpttrf', dpttrf );\n\n/**\n* @name iladlc\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/iladlc}\n*/\nimport iladlc from './../../base/iladlc';\nsetReadOnly( ns, 'iladlc', iladlc );\n\n/**\n* @name iladlr\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/iladlr}\n*/\nimport iladlr from './../../base/iladlr';\nsetReadOnly( ns, 'iladlr', iladlr );\n\n/**\n* @name sgetrans\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/sge-trans}\n*/\nimport sgetrans from './../../base/sge-trans';\nsetReadOnly( ns, 'sgetrans', sgetrans );\n\n/**\n* @name slacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/slacpy}\n*/\nimport slacpy from './../../base/slacpy';\nsetReadOnly( ns, 'slacpy', slacpy );\n\n/**\n* @name slaswp\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/slaswp}\n*/\nimport slaswp from './../../base/slaswp';\nsetReadOnly( ns, 'slaswp', slaswp );\n\n/**\n* @name spttrf\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/spttrf}\n*/\nimport spttrf from './../../base/spttrf';\nsetReadOnly( ns, 'spttrf', spttrf );\n\n/**\n* @name zlacgv\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zlacgv}\n*/\nimport zlacgv from './../../base/zlacgv';\nsetReadOnly( ns, 'zlacgv', zlacgv );\n\n/**\n* @name zlacpy\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zlacpy}\n*/\nimport zlacpy from './../../base/zlacpy';\nsetReadOnly( ns, 'zlacpy', zlacpy );\n\n/**\n* @name zlaset\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zlaset}\n*/\nimport zlaset from './../../base/zlaset';\nsetReadOnly( ns, 'zlaset', zlaset );\n\n/**\n* @name zlaswp\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zlaswp}\n*/\nimport zlaswp from './../../base/zlaswp';\nsetReadOnly( ns, 'zlaswp', zlaswp );\n\n/**\n* @name zrot\n* @memberof ns\n* @readonly\n* @type {Function}\n* @see {@link module:@stdlib/lapack/base/zrot}\n*/\nimport zrot from './../../base/zrot';\nsetReadOnly( ns, 'zrot', zrot );\n\n\n// EXPORTS //\n\nexport default ns;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport abs from '@stdlib/math/base/special/abs';\nimport min from '@stdlib/math/base/special/min';\nimport max from '@stdlib/math/base/special/max';\nimport sqrt from '@stdlib/math/base/special/sqrt';\nimport abs2 from '@stdlib/math/base/special/abs2';\n\n\n// MAIN //\n\n/**\n* Returns `sqrt(x^2 + y^2)` in a manner which doesn't cause unnecessary overflow.\n*\n* @param {number} x - first input number\n* @param {number} y - second input number\n* @returns {number} `sqrt(x^2 + y^2)`\n*\n* @example\n* var out = dlapy2( 3.0, 4.0 );\n* // returns 5.0\n*/\nfunction dlapy2( x, y ) {\n\tvar xabs;\n\tvar yabs;\n\tvar w;\n\tvar z;\n\n\txabs = abs( x );\n\tyabs = abs( y );\n\n\tw = max( xabs, yabs );\n\tz = min( xabs, yabs );\n\n\tif ( z === 0.0 ) {\n\t\treturn w;\n\t}\n\treturn w * ( sqrt( 1.0 + abs2( z / w ) ) );\n}\n\n\n// EXPORTS //\n\nexport default dlapy2;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport abs from '@stdlib/math/base/special/abs';\nimport dlamch from './../../../base/dlamch';\nimport max from '@stdlib/math/base/special/maxn';\nimport sqrt from '@stdlib/math/base/special/sqrt';\nimport abs2 from '@stdlib/math/base/special/abs2';\n\n\n// MAIN //\n\n/**\n* Computes `sqrt(x^2 + y^2 + z^2)` in a manner which doesn't cause unnecessary overflow.\n*\n* @param {number} x - first input number\n* @param {number} y - second input number\n* @param {number} z - third input number\n* @returns {number} `sqrt(x^2 + y^2 + z^2)`\n*\n* @example\n* var out = dlapy3( 3.0, 4.0, 12.0 );\n* // returns 13.0\n*/\nfunction dlapy3( x, y, z ) {\n\tvar hugeval;\n\tvar xabs;\n\tvar yabs;\n\tvar zabs;\n\tvar w;\n\n\thugeval = dlamch( 'O' );\n\txabs = abs( x );\n\tyabs = abs( y );\n\tzabs = abs( z );\n\n\tw = max( xabs, yabs, zabs );\n\n\tif ( w === 0.0 || w > hugeval ) {\n\t\treturn xabs + yabs + zabs;\n\t}\n\treturn w * sqrt( abs2( xabs / w ) + abs2( yabs / w ) + abs2( zabs / w ) );\n}\n\n\n// EXPORTS //\n\nexport default dlapy3;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/*\n* When adding modules to the namespace, ensure that they are added in alphabetical order according to module name.\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils/define-read-only-property';\n\n\n// MAIN //\n\n/**\n* Top-level namespace.\n*\n* @namespace ns\n*/\nvar ns = {};\n\n/**\n* @name base\n* @memberof ns\n* @readonly\n* @type {Namespace}\n* @see {@link module:@stdlib/lapack/base}\n*/\nimport base from './../base';\nsetReadOnly( ns, 'base', base );\n\n\n// EXPORTS //\n\nexport default ns;\n"],"names":["clacgv","N","cx","strideCX","offsetCX","cx32","ix","sx","i","reinterpret","ndarray","stride2offset","setReadOnly","clacpy","uplo","M","A","strideA1","strideA2","offsetA","B","strideB1","strideB2","offsetB","viewA","viewB","ia","ib","i0","i1","ja","jb","isRowMajor","min","copyUpper","copyLower","da0","da1","db0","db1","sh","S0","S1","sa","sb","o","loopOrder","sy","copyAll","order","LDA","LDB","sa1","sa2","sb1","sb2","isLayout","TypeError","format","isColumnMajor","RangeError","base","tmp","tryRequire","join","require$$0","clacpy$1","isError","main","setDiagonal","breal","bimag","claset","alpha","beta","ar","ai","br","bi","realf","imagf","areal","aimag","idx","setUpper","setLower","setAll","claset$1","BLOCK_SIZE","claswp","k1","k2","inck","IPIV","strideIPIV","offsetIPIV","nrows","n32","row","ia1","ia2","ip","j","k","n","cswap","floor","incx","inc","io","max","claswp$1","crot","cy","strideCY","offsetCY","c","s","viewX","viewY","sr","si","iy","yr","yi","xr","xi","f32","dgetrans","out","strideO1","strideO2","offsetO","do0","do1","LDO","so1","so2","dgetrans$1","dgttrf","DL","strideDL","offsetDL","D","strideD","offsetD","DU","strideDU","offsetDU","DU2","strideDU2","offsetDU2","fact","temp","idu2","idu","idl","id","abs","dgttrf$1","dlacpy","Float64Array","dladiv","a","b","d","P","offsetP","Q","offsetQ","cdiv","dladiv$1","RADIX","dlamch","cmach","lowercase","charAt","FLOAT64_EPS","FLOAT64_SMALLEST_NORMAL","FLOAT64_PRECISION","FLOAT64_MIN_EXPONENT","FLOAT64_MAX_EXPONENT","FLOAT64_MAX","iladlr","last","iladlr$1","iladlc","iladlc$1","isLeftSide","side","dlarf1f","V","strideV","offsetV","tau","C","strideC1","strideC2","offsetC","work","strideWork","offsetWork","lastv","lastc","dscal","dgemv","daxpy","dger","LDC","sc1","sc2","isOperationSide","operationSides","dlarf1f$1","dlaset","dlaset$1","SBIG","SSML","TBIG","TSML","dlassq","X","strideX","offsetX","scale","sumsq","strideOut","offsetOut","notbig","abig","asml","amed","ymin","ymax","ax","ox","isnan","abs2","sqrt","dlassq$1","dlaswp","dswap","dlaswp$1","dpttrf","E","strideE","offsetE","ie","v","dpttrf$1","sgetrans","sgetrans$1","slacpy","slacpy$1","slaswp","sswap","slaswp$1","spttrf","spttrf$1","zlacgv","zx","strideZX","offsetZX","zx64","zlacpy","zlacpy$1","zlaset","real","imag","zlaset$1","zlaswp","zswap","zlaswp$1","zrot","zy","strideY","offsetY","ns","x","y","xabs","yabs","w","z","hugeval","zabs"],"mappings":"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"}